<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>Puppet-And-Git</title>
	<meta name="author" content="Anthony Dawson"/>
</head>
<body>

<p><link href="markdown2.css" rel="stylesheet"></link></p>

<h2 id="puppettraining">Puppet Training</h2>

<h3 id="chapter1-downloadingthetoolsyouneed">Chapter 1 - Downloading the Tools you need</h3>

<h4 id="installinggitanddownloadingtherepo">Installing Git and downloading the repo</h4>

<p>To get a copy of the repo that accompanies this book, follow these steps:</p>

<ul>
<li>Browse to https://git-scm.com/downloads</li>
<li>Download and install the right version of Git for your operating system.</li>
<li>Run the following command:</li>
</ul>

<pre><code class="Shell">git clone https://github.com/bitfield/puppet-beginners-guide-3.git
</code></pre>

<h4 id="installingvirtualboxandvagrant">Installing VirtualBox and Vagrant</h4>

<p>If you already have a Linux machine or cloud server you&#8217;d like to use for working through the examples, skip this section and move on to the next chapter. </p>

<p>If you&#8217;d like to use VirtualBox and Vagrant to run a local virtual machine (VM) on your computer to use with the examples, follow these instructions:</p>

<ul>
<li>Browse to https://www.virtualbox.org/</li>
<li>Download and install the right version of VirtualBox for your operating system</li>
<li>Browse to https://www.vagrantup.com/downloads.html</li>
<li>Select the right version of Vagrant for your operating system: OS X, Windows, and so on</li>
<li>Follow the instructions to install the software</li>
</ul>

<h4 id="runningyourvagrantvm">Running your Vagrant VM</h4>

<p>Once you have installed Vagrant, you can start the Puppet Beginner&#8217;s Guide virtual machine.</p>

<p>Run the following commands:</p>

<pre><code class="Shell">cd puppet-beginners-guide-3
scripts/start_vagrant.sh
</code></pre>

<p>  Vagrant will begin downloading the base box. Once that has booted, it will install Puppet. </p>

<p>This may take a while, but once the installation is complete, the virtual machine will be ready to use.</p>

<p>Connect to the VM with the following command:</p>

<pre><code class="Shell">vagrant ssh
</code></pre>

<p>You now have a command-line shell on the VM. Check that Puppet is installed and working by running the following command (you may get a different version number, which is fine):</p>

<pre><code class="Shell">puppet --version
5.2.0
</code></pre>

<h3 id="chapter2-creatingyourfirstmanifests">Chapter 2 - Creating your first manifests</h3>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ export LANG=C
vagrant@ubuntu-xenial:~$ export LC_ALL=C
</code></pre>

<p>On your Vagrant box, run the following command:</p>

<pre><code class="Shell">sudo puppet apply /examples/file_hello.pp
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.07 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/ensure: defined content as '{md5}22c3683b094136c3398391ae71b20f04'
Notice: Applied catalog in 0.01 seconds
</code></pre>

<h4 id="understandingthecode">Understanding the code</h4>

<p>Let&#8217;s look at the example code to see what&#8217;s going on (run <code>cat /example/file_hello.pp</code>, or open the file in a text editor):</p>

<pre><code class="Shell">file { '/tmp/hello.txt':
  ensure  =&gt; file,
  content =&gt; &quot;hello, world\n&quot;,
}
</code></pre>

<p>The code term <code>file</code> begins a <strong>resource declaration</strong> for a <code>file</code> resource. A <strong>resource</strong> is some bit of configuration that you want Puppet to manage: for example, a file, user account, or package. A resource declaration follows this pattern:</p>

<pre><code class="Shell">RESOURCE_TYPE { TITLE:
  ATTRIBUTE =&gt; VALUE,
  ...
}
</code></pre>

<p>Resource declarations will make up almost all of your Puppet manifests, so it&#8217;s important to understand exactly how they work:</p>

<ul>
<li><code>RESOURCE_TYPE</code> indicates the type of resource you&#8217;re declaring; in this case, it&#8217;s a <code>file</code>.</li>
<li><code>TITLE</code> is the name that Puppet uses to identify the resource internally.</li>
</ul>

<p>Every resource must have a unique title. With <code>file</code> resources, it&#8217;s usual for this to be the full path to the file: in this case, <code>/tmp/hello</code>.</p>

<p>The remainder of this block of code is a list of attributes that describe how the resource should be configured. The attributes available depend on the type of the resource. For a file, you can set attributes such as <code>content</code>, <code>owner</code>, <code>group</code>, and <code>mode</code>, but one attribute that every resource supports is <code>ensure</code>.</p>

<p>Again, the possible values for <code>ensure</code> are specific to the type of resource. In this case, we use <code>file</code> to indicate that we want a regular file, as opposed to a directory or symlink:</p>

<pre><code class="Shell">ensure  =&gt; file,
</code></pre>

<p>Next, to put some text in the file, we specify the <code>content</code> attribute:</p>

<pre><code class="Shell">content =&gt; &quot;hello, world\n&quot;,
</code></pre>

<p>The <code>content</code> attribute sets the contents of a file to a string value you provide. Here, the contents of the file are declared to be <code>hello, world</code>, followed by a newline character (in Puppet strings, we write the newline character as \n).</p>

<p>Note that <code>content</code> specifies the entire content of the file; the string you provide will replace anything already in the file, rather than be appended to it.</p>

<h5 id="modifyingexistingfiles">Modifying existing files</h5>

<p>What happens if the file already exists when Puppet runs and it contains something else? Will Puppet change it?</p>

<pre><code class="Shell">sudo sh -c 'echo &quot;goodbye, world&quot; &gt;/tmp/hello.txt'
cat /tmp/hello.txt
goodbye, world

sudo puppet apply /examples/file_hello.pp
cat /tmp/hello.txt
hello, world
</code></pre>

<p>Yes!</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ sudo sh -c 'echo &quot;goodbye, world&quot; &gt;/tmp/hello.txt'
vagrant@ubuntu-xenial:~$ cat /tmp/hello.txt
goodbye, world
vagrant@ubuntu-xenial:~$ sudo puppet apply /examples/file_hello.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content: content changed '{md5}767887814e925822027f4fe63fb69ce2' to '{md5}22c3683b094136c3398391ae71b20f04'
Notice: Applied catalog in 0.03 seconds
vagrant@ubuntu-xenial:~$ cat /tmp/hello.txt
hello, world
vagrant@ubuntu-xenial:~$
</code></pre>

<p>If any attribute of the file, including its contents, doesn&#8217;t match the manifest, Puppet will change it so that it does.</p>

<p>This can lead to some surprising results if you manually edit a file managed by Puppet. If you make changes to a file without also changing the Puppet manifest to match, Puppet will overwrite the file the next time it runs, and your changes will be lost.</p>

<p>So it&#8217;s a good idea to add a comment to files that Puppet is managing: something like the following:</p>

<pre><code class="Shell"># This file is managed by Puppet - any manual edits will be lost
</code></pre>

<p>Add this to Puppet&#8217;s copy of the file when you first deploy it, and it will remind you and others not to make manual changes.</p>

<h5 id="dry-runningpuppet">Dry-running puppet</h5>

<p>Because you can&#8217;t necessarily tell in advance what applying a Puppet manifest will change on the system, it&#8217;s a good idea to do a dry run first. </p>

<p>Adding the <code>—noop</code> flag to <code>puppet apply</code> will show you what Puppet would have done, without actually changing anything:</p>

<pre><code class="Shell">sudo sh -c 'echo &quot;goodbye, world&quot; &gt;/tmp/hello.txt'
sudo puppet apply --noop /examples/file_hello.pp
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.04 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content: current_value {md5}7678..., should be {md5}22c3... (noop)
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ sudo puppet apply --noop /examples/file_hello.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content: current_value '{md5}767887814e925822027f4fe63fb69ce2', should be '{md5}22c3683b094136c3398391ae71b20f04' (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 event
Notice: Stage[main]: Would have triggered 'refresh' from 1 event
Notice: Applied catalog in 0.01 seconds
</code></pre>

<p>Puppet decides whether or not a <code>file</code> resource needs updating, based on its MD5 hash sum. In the previous example, Puppet reports that the current value of the hash sum for <code>/tmp/hello.txt</code> is <code>7678…</code>, whereas according to the manifest, it should be <code>22c3…</code>. </p>

<p>Accordingly, the file will be changed on the next Puppet run.</p>

<p>If you want to see what change Puppet would actually make to the file, you can use the <code>—show_diff</code> option:</p>

<pre><code class="Shell">sudo puppet apply --noop --show_diff /examples/file_hello.pp
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.04 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content:
--- /tmp/hello.txt      2017-02-13 02:27:13.186261355 -0800
+++ /tmp/puppet-file20170213-3671-2yynjt        2017-02-13 02:30:26.561834755 -0800
@@ -1 +1 @@
-goodbye, world
+hello, world
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ sudo puppet apply --noop --show_diff /examples/file_hello.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content:
--- /tmp/hello.txt  2018-10-16 09:06:53.202787401 +0000
+++ /tmp/puppet-file20181016-27923-lyslrb   2018-10-16 09:10:31.842787401 +0000
@@ -1 +1 @@
-goodbye, world
+hello, world

Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content: current_value '{md5}767887814e925822027f4fe63fb69ce2', should be '{md5}22c3683b094136c3398391ae71b20f04' (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 event
Notice: Stage[main]: Would have triggered 'refresh' from 1 event
Notice: Applied catalog in 0.02 seconds
</code></pre>

<p>These options are very useful when you want to make sure that your Puppet manifest will affect only the things you&#8217;re expecting it to—or, sometimes, when you want to check if something has been changed outside Puppet without actually undoing the change.</p>

<h5 id="howpuppetappliesthemanifest">How puppet applies the manifest</h5>

<p>Here&#8217;s how your manifest is processed. </p>

<p>First, Puppet reads the manifest and the list of resources it contains (in this case, there&#8217;s just one resource), and compiles these into a catalog (an internal representation of the desired state of the node).</p>

<p>Puppet then works through the catalog, applying each resource in turn:</p>

<ul>
<li>First, it checks if the resource exists on the server. If not, Puppet creates it. In the example, we&#8217;ve declared that the file <code>/tmp/hello.txt</code> should exist. The first time you run <code>sudo puppet apply</code>, this won&#8217;t be the case, so Puppet will create the file for you.</li>
<li>Then, for each resource, it checks the value of each attribute in the catalog against what actually exists on the server. In our example, there&#8217;s just one attribute: <code>content</code>. We&#8217;ve specified that the content of the file should be <code>hello, world\n</code>. If the file is empty or contains something else, Puppet will overwrite the file with what the catalog says it should contain.</li>
</ul>

<p>In this case, the file will be empty the first time you apply the catalog, so Puppet will write the string <code>hello, world\n</code> into it.</p>

<p>We&#8217;ll go on to examine the <code>file</code> resource in much more detail in later chapters.</p>

<h5 id="creatingafileofyourown">Creating a file of your own</h5>

<p>Create your own manifest file (you can name it anything you like, so long as the file extension is <code>.pp</code>). </p>

<p>Use a <code>file</code> resource to create a file on the server with any contents you like. Apply the manifest with Puppet and check that the file is created and contains the text you specified.</p>

<p>Edit the file directly and change the contents, then re-apply Puppet and check that it changes the file back to what the manifest says it should contain.</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ cat file_tonytest.pp
file { '/tmp/tonytest.txt’:
    ensure  =&gt; file,
    content =&gt; &quot;Hi there,\nMy name is AJ9\n&quot;,
}
</code></pre>

<p>Run with:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ sudo puppet apply --noop --show_diff /examples/file_tonytest.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/file_tonytest.pp]/ensure: current_value 'absent', should be 'file' (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 event
Notice: Stage[main]: Would have triggered 'refresh' from 1 event
Notice: Applied catalog in 0.01 seconds
vagrant@ubuntu-xenial:/examples$
</code></pre>

<p>This shows that the file is absent and would apply it.</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ sudo puppet apply /examples/file_tonytest.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/tonytest.txt]/ensure: defined content as '{md5}9fbae0c049b280b2cc1a056e7a801f4e'
Notice: Applied catalog in 0.01 seconds
</code></pre>

<p>Which applies the file with the content expected:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ cat /tmp/tonytest.txt
Hi there,
My name is AJ9
</code></pre>

<p>Changing the <code>ensure =&gt; file</code> to <code>ensure =&gt; absent</code> will remove the file.</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ cat /tmp/tonytest.txt
cat: /tmp/tonytest.txt: No such file or directory
</code></pre>

<p>Examples:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ sudo puppet apply --noop --show_diff /examples/file_tonytest.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/tonytest.txt]/content:
--- /tmp/tonytest.txt   2018-10-16 09:38:58.358787401 +0000
+++ /tmp/puppet-file20181016-28487-1ejofut  2018-10-16 09:39:13.902787401 +0000
@@ -1,2 +1,2 @@
 Hi there,
-My name is Freya
+My name is AJ9

Notice: /Stage[main]/Main/File[/tmp/tonytest.txt]/content: current_value '{md5}366b6b35868ee843d3cd5c4368104055', should be '{md5}9fbae0c049b280b2cc1a056e7a801f4e' (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 event
Notice: Stage[main]: Would have triggered 'refresh' from 1 event
Notice: Applied catalog in 0.02 seconds
vagrant@ubuntu-xenial:/examples$ sudo puppet apply /examples/file_tonytest.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.01 seconds
Notice: /Stage[main]/Main/File[/tmp/tonytest.txt]/content: content changed '{md5}366b6b35868ee843d3cd5c4368104055' to '{md5}9fbae0c049b280b2cc1a056e7a801f4e'
Notice: Applied catalog in 0.03 seconds
vagrant@ubuntu-xenial:/examples$ cat /tmp/tonytest.txt
Hi there,
My name is AJ9
</code></pre>

<h4 id="managingpackages">Managing Packages</h4>

<p>Another key resource type in Puppet is the <strong>package</strong>. A major part of configuring servers by hand involves installing packages, so we will also be using packages a lot in Puppet manifests. </p>

<p>Although every operating system has its own package format, and different formats vary quite a lot in their capabilities, Puppet represents all these possibilities with a single <code>package</code> type. </p>

<p>If you specify in your Puppet manifest that a given package should be installed, Puppet will use the appropriate package manager commands to install it on whatever platform it&#8217;s running on.</p>

<p>As you&#8217;ve seen, all resource declarations in Puppet follow this form:</p>

<pre><code class="Shell">RESOURCE_TYPE { TITLE:
  ATTRIBUTE =&gt; VALUE,
  ...
}
</code></pre>

<p><code>package</code> resources are no different. The <code>RESOURCE_TYPE</code> is <code>package</code>, and the only attribute you usually need to specify is <code>ensure</code>, and the only value it usually needs to take is <code>installed</code>:</p>

<pre><code class="Shell">package { 'cowsay':
  ensure =&gt; installed,
}
</code></pre>

<p>For example:</p>

<pre><code class="Shell">sudo puppet apply /examples/package.pp
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.52 seconds
Notice: /Stage[main]/Main/Package[cowsay]/ensure: created
Notice: Applied catalog in 29.53 seconds
</code></pre>

<p>Let&#8217;s see whether <code>cowsay</code> is installed:</p>

<pre><code class="Shell">cowsay Puppet rules!
 _______________
&lt; Puppet rules! &gt;
 ---------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre>

<p>Not the most useful package, but it demonstrates the principle.</p>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ cat package.pp
package { 'cowsay':
  ensure =&gt; installed,
}

vagrant@ubuntu-xenial:/examples$ sudo puppet apply /examples/package.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.42 seconds
Notice: /Stage[main]/Main/Package[cowsay]/ensure: created
Notice: Applied catalog in 1.52 seconds

vagrant@ubuntu-xenial:/examples$ cowsay Hello Tony!
 _____________
&lt; Hello Tony! &gt;
 -------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre>

<h5 id="howpuppetappliesthemanifest-package">How puppet applies the manifest - Package</h5>

<p>The title of the <code>package</code> resource is <code>cowsay</code>, so Puppet knows that we&#8217;re talking about a package named <code>cowsay</code>.</p>

<p>The <code>ensure</code> attribute governs the installation state of packages: unsurprisingly, <code>installed </code>tells Puppet that the package should be installed.</p>

<p>As we saw in the earlier example, Puppet processes this manifest by examining each resource in turn and checking its attributes on the server against those specified in the manifest. </p>

<p>In this case, Puppet will look for the <code>cowsay</code> package to see whether it&#8217;s installed. It is not, but the manifest says it should be, so Puppet carries out all the necessary actions to make reality match the manifest, which here means installing the package.</p>

<h5 id="exercise">Exercise</h5>

<p>Create a manifest that uses the <code>package</code> resource to install any software you find useful for managing servers. </p>

<p>Here are some suggestions: <code>tmux</code>, <code>sysdig</code>, <code>atop</code>, <code>htop</code>, and <code>dstat</code>.</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ cat package_manage_servers.pp
package { 'tmux':
    ensure  =&gt; installed,
}

package { 'sysdig':
    ensure  =&gt; installed,
}

package { 'atop':
    ensure  =&gt; installed,
}

package { 'htop':
    ensure  =&gt; installed,
}

package { 'dstat':
    ensure  =&gt; installed,
}
</code></pre>

<p>Which produced:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ sudo puppet apply /examples/package_manage_servers.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.44 seconds
Notice: /Stage[main]/Main/Package[sysdig]/ensure: created
Notice: /Stage[main]/Main/Package[atop]/ensure: created
Notice: /Stage[main]/Main/Package[htop]/ensure: created
Notice: /Stage[main]/Main/Package[dstat]/ensure: created
Notice: Applied catalog in 23.02 seconds
</code></pre>

<h4 id="queryingresourceswiththepuppetresource">Querying resources with the puppet resource</h4>

<p>If you want to see what version of a package Puppet thinks you have installed, you can use the <code>puppet resource</code> tool:</p>

<pre><code class="Shell">puppet resource package openssl
package { 'openssl':
  ensure =&gt; '1.0.2g-1ubuntu4.8',
}
</code></pre>

<p><code>puppet resource TYPE TITLE</code> will output a Puppet manifest representing the current state of the named resource on the system. </p>

<p>If you leave out <code>TITLE</code>, you&#8217;ll get a manifest for all the resources of the type <code>TYPE</code>. </p>

<p>For example, if you run <code>puppet resource package</code>, you&#8217;ll see the Puppet code for all the packages installed on the system.</p>

<p><code>puppet resource</code> even has an interactive configuration feature. </p>

<p>To use it, run the following command:</p>

<pre><code class="Shell">puppet resource -e package openssl
</code></pre>

<p>If you run this, Puppet will generate a manifest for the current state of the resource, and open it in an editor. </p>

<p>If you now make changes and save it, Puppet will apply that manifest to make changes to the system. This is a fun little feature, but it would be rather time-consuming to do your entire configuration this way.</p>

<p>In an editor you would get:</p>

<pre><code>package { 'openssl':
  ensure =&gt; '1.0.2g-1ubuntu4.13',
}
</code></pre>

<h4 id="services">Services</h4>

<p>The third most important Puppet resource type is the <strong>service</strong>: a long-running process that either does some continuous kind of work, or waits for requests and then acts on them. </p>

<p>For example, on most systems, the <code>sshd</code> process runs all the time and listens for SSH login attempts.</p>

<p>Puppet models services with the <code>service</code> resource type. The <code>service</code> resources look like the following example (you can find this in <code>service.pp</code> in the <code>/examples/</code> directory. </p>

<p>From now on, I&#8217;ll just give the filename of each example, as they are all in the same directory):</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ more service.pp
service { 'sshd':
  ensure =&gt; running,
  enable =&gt; true,
}
</code></pre>

<p>The <code>ensure</code> parameter governs whether the service should be running or not. </p>

<p>If its value is <code>running</code>, then as you might expect, Puppet will start the service if it is not running. </p>

<p>If you set <code>ensure</code> to <code>stopped</code>, Puppet will stop the service if it is running.</p>

<p>Services may also be set to start when the system boots, using the <code>enable</code> parameter. </p>

<p>If <code>enable</code> is set to <code>true</code>, the service will start at boot. If, on the other hand, <code>enable</code> is set to <code>false</code>, it will not. </p>

<p>Generally speaking, unless there&#8217;s a good reason not to, all services should be set to start at boot.</p>

<h5 id="gettinghelponresourceswithpuppetdescribe">Getting help on resources with puppet describe</h5>

<p>If you&#8217;re struggling to remember all the different attributes of all the different resources, Puppet has a built-in help feature that will remind you. </p>

<p>Run the following command, for example:</p>

<pre><code class="Shell">puppet describe service
</code></pre>

<p>This will give a description of the <code>service</code> resource, along with a complete list of attributes and allowed values. </p>

<p>This works for all built-in resource types as well as many provided by third-party modules. To see a list of all the available resource types, run the following command:</p>

<pre><code class="Shell">puppet describe --list
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ puppet describe --list
These are the types known to puppet:
augeas          - Apply a change or an array of changes to the  ...
cron            - Installs and manages cron jobs
exec            - Executes external commands
file            - Manages files, including their content, owner ...
filebucket      - A repository for storing and retrieving file  ...
group           - Manage groups
host            - Installs and manages host entries
mount           - Manages mounted filesystems, including puttin ...
notify          - .. no documentation ..
package         - Manage packages
resources       - This is a metatype that can manage other reso ...
schedule        - Define schedules for Puppet
scheduled_task  - Installs and manages Windows Scheduled Tasks
selboolean      - Manages SELinux booleans on systems with SELi ...
selmodule       - Manages loading and unloading of SELinux poli ...
service         - Manage running services
ssh_authorized_key - Manages SSH authorized keys
sshkey          - Installs and manages ssh host keys
stage           - A resource type for creating new run stages
tidy            - Remove unwanted files based on specific crite ...
user            - Manage users
whit            - Whits are internal artifacts of Puppet's curr ...
yumrepo         - The client-side description of a yum reposito ...
zfs             - Manage zfs
zone            - Manages Solaris zones
zpool           - Manage zpools
</code></pre>

<h6 id="crondescribed">Cron Described</h6>

<pre><code class="vagrant@ubuntu-xenial:/examples$ puppet describe cron">
cron
====
Installs and manages cron jobs. Every cron resource created by Puppet
requires a command and at least one periodic attribute (hour, minute,
month, monthday, weekday, or special). While the name of the cron job is
not part of the actual job, the name is stored in a comment beginning with
`# Puppet Name: `. These comments are used to match crontab entries created
by Puppet with cron resources.
If an existing crontab entry happens to match the scheduling and command of
a
cron resource that has never been synced, Puppet defers to the existing
crontab entry and does not create a new entry tagged with the `# Puppet
Name: `
comment.
Example:
    cron { 'logrotate':
      command =&gt; '/usr/sbin/logrotate',
      user    =&gt; 'root',
      hour    =&gt; 2,
      minute  =&gt; 0,
    }
Note that all periodic attributes can be specified as an array of values:
    cron { 'logrotate':
      command =&gt; '/usr/sbin/logrotate',
      user    =&gt; 'root',
      hour    =&gt; [2, 4],
    }
...or using ranges or the step syntax `*/2` (although there's no guarantee
that your `cron` daemon supports these):
    cron { 'logrotate':
      command =&gt; '/usr/sbin/logrotate',
      user    =&gt; 'root',
      hour    =&gt; ['2-4'],
      minute  =&gt; '*/10',
    }
**Important:** _The Cron type will not reset parameters that are
removed from a manifest_. For example, removing a `minute =&gt; 10` parameter
will not reset the minute component of the associated cronjob to `*`.
These changes must be expressed by setting the parameter to
`minute =&gt; absent` because Puppet only manages parameters that are out of
sync with manifest entries.
**Autorequires:** If Puppet is managing the user account specified by the
`user` property of a cron resource, then the cron resource will autorequire
that user.


Parameters
----------

- **command**
    The command to execute in the cron job.  The environment
    provided to the command varies by local system rules, and it is
    best to always provide a fully qualified command.  The user's
    profile is not sourced when the command is run, so if the
    user's environment is desired it should be sourced manually.
    All cron parameters support `absent` as a value; this will
    remove any existing values for that field.

- **ensure**
    The basic property that the resource should be in.
    Valid values are `present`, `absent`.

- **environment**
    Any environment settings associated with this cron job.  They
    will be stored between the header and the job in the crontab.  There
    can be no guarantees that other, earlier settings will not also
    affect a given cron job.
    Also, Puppet cannot automatically determine whether an existing,
    unmanaged environment setting is associated with a given cron
    job.  If you already have cron jobs with environment settings,
    then Puppet will keep those settings in the same place in the file,
    but will not associate them with a specific job.

    Settings should be specified exactly as they should appear in
    the crontab, like `PATH=/bin:/usr/bin:/usr/sbin`.


- **hour**
    The hour at which to run the cron job. Optional;
    if specified, must be between 0 and 23, inclusive.

- **minute**
    The minute at which to run the cron job.
    Optional; if specified, must be between 0 and 59, inclusive.

- **month**
    The month of the year. Optional; if specified,
    must be either:
    -   A number between 1 and 12, inclusive, with 1 being January
    -   The name of the month, such as 'December'.

- **monthday**
    The day of the month on which to run the
    command.  Optional; if specified, must be between 1 and 31.

- **name**
    The symbolic name of the cron job.  This name
    is used for human reference only and is generated automatically
    for cron jobs found on the system.  This generally won't
    matter, as Puppet will do its best to match existing cron jobs
    against specified jobs (and Puppet adds a comment to cron jobs it adds),
    but it is at least possible that converting from unmanaged jobs to
    managed jobs might require manual intervention.

- **special**
    A special value such as 'reboot' or 'annually'.
    Only available on supported systems such as Vixie Cron.
    Overrides more specific time of day/week settings.
    Set to 'absent' to make puppet revert to a plain numeric schedule.

- **target**
    The name of the crontab file in which the cron job should be stored.
    This property defaults to the value of the `user` property if set, the
    user running Puppet or `root`.
    For the default crontab provider, this property is functionally
    equivalent to the `user` property and should be avoided. In particular,
    setting both `user` and `target` to different values will result in
    undefined behavior.

- **user**
    The user who owns the cron job.  This user must
    be allowed to run cron jobs, which is not currently checked by
    Puppet.
    This property defaults to the user running Puppet or `root`.
    The default crontab provider executes the system `crontab` using
    the user account specified by this property.

- **weekday**
    The weekday on which to run the command. Optional; if specified,
    must be either:
    -   A number between 0 and 7, inclusive, with 0 or 7 being Sunday
    -   The name of the day, such as 'Tuesday'.

Providers
---------
    Crontab
</code></pre>

<h6 id="service">Service</h6>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ puppet describe service

service
=======
Manage running services.  Service support unfortunately varies
widely by platform --- some platforms have very little if any concept of a
running service, and some have a very codified and powerful concept.
Puppet's service support is usually capable of doing the right thing, but
the more information you can provide, the better behaviour you will get.
Puppet 2.7 and newer expect init scripts to have a working status command.
If this isn't the case for any of your services' init scripts, you will
need to set `hasstatus` to false and possibly specify a custom status
command in the `status` attribute. As a last resort, Puppet will attempt to
search the process table by calling whatever command is listed in the `ps`
fact. The default search pattern is the name of the service, but you can
specify it with the `pattern` attribute.
**Refresh:** `service` resources can respond to refresh events (via
`notify`, `subscribe`, or the `~&gt;` arrow). If a `service` receives an
event from another resource, Puppet will restart the service it manages.
The actual command used to restart the service depends on the platform and
can be configured:
* If you set `hasrestart` to true, Puppet will use the init script's restart
command.
* You can provide an explicit command for restarting with the `restart`
attribute.
* If you do neither, the service's stop and start commands will be used.


Parameters
----------

- **binary**
    The path to the daemon.  This is only used for
    systems that do not support init scripts.  This binary will be
    used to start the service if no `start` parameter is
provided.

- **control**
    The control variable used to manage services (originally for HP-UX).
    Defaults to the upcased service name plus `START` replacing dots with
    underscores, for those providers that support the `controllable`
    feature.

- **enable**
    Whether a service should be enabled to start at boot.
    This property behaves quite differently depending on the platform;
    wherever possible, it relies on local tools to enable or disable
    a given service.
    Valid values are `true`, `false`, `manual`, `mask`.
    Requires features enableable.

- **ensure**
    Whether a service should be running.
    Valid values are `stopped` (also called `false`), `running` (also called
    `true`).

- **flags**
    Specify a string of flags to pass to the startup script.
    Requires features flaggable.

- **hasrestart**
    Specify that an init script has a `restart` command.  If this is
    false and you do not specify a command in the `restart` attribute,
    the init script's `stop` and `start` commands will be used.
    Valid values are `true`, `false`.

- **hasstatus**
    Declare whether the service's init script has a functional status
    command. This attribute's default value changed in Puppet 2.7.0.
    The init script's status command must return 0 if the service is
    running and a nonzero value otherwise. Ideally, these exit codes
    should conform to [the LSB's specification][lsb-exit-codes] for init
    script status actions, but Puppet only considers the difference
    between 0 and nonzero to be relevant.
    If a service's init script does not support any kind of status command,
    you should set `hasstatus` to false and either provide a specific
    command using the `status` attribute or expect that Puppet will look for
    the service name in the process table. Be aware that 'virtual' init
    scripts (like 'network' under Red Hat systems) will respond poorly to
    refresh events from other resources if you override the default behavior
    without providing a status command.
Valid values are `true`, `false`.

- **manifest**
    Specify a command to config a service, or a path to a manifest to do so.

- **name**
    The name of the service to run.
    This name is used to find the service; on platforms where services
    have short system names and long display names, this should be the
    short name. (To take an example from Windows, you would use &quot;wuauserv&quot;
    rather than &quot;Automatic Updates.&quot;)

- **path**
    The search path for finding init scripts.  Multiple values should
    be separated by colons or provided as an array.

- **pattern**
    The pattern to search for in the process table.
    This is used for stopping services on platforms that do not
    support init scripts, and is also used for determining service
    status on those service whose init scripts do not include a status
    command.
    Defaults to the name of the service. The pattern can be a simple string
    or any legal Ruby pattern, including regular expressions (which should
    be quoted without enclosing slashes).

- **restart**
    Specify a *restart* command manually.  If left
    unspecified, the service will be stopped and then started.

- **start**
    Specify a *start* command manually.  Most service subsystems
    support a `start` command, so this will not need to be
specified.

- **status**
    Specify a *status* command manually.  This command must
    return 0 if the service is running and a nonzero value otherwise.
    Ideally, these exit codes should conform to [the LSB's
    specification][lsb-exit-codes] for init script status actions, but
    Puppet only considers the difference between 0 and nonzero to be
    relevant.
    If left unspecified, the status of the service will be determined
    automatically, usually by looking for the service in the process
    table.
    [lsb-exit-codes]:
    http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-
    generic/iniscrptact.html

- **stop**
    Specify a *stop* command manually.

Providers
---------
    base, bsd, daemontools, debian, freebsd, gentoo, init, launchd, openbsd,
    openrc, openwrt, rcng, redhat, runit, service, smf, src, systemd,
    upstart, windows
</code></pre>

<h5 id="thepackage-file-servicepattern">The package-file-service pattern</h5>

<p>It&#8217;s very common for a given piece of software to require all three of the above mentioned Puppet resource types: the <code>package</code> resource installs the software, the <code>file</code> resource deploys one or more configuration files required for the software, and the <code>service</code> resource runs the software itself.</p>

<p>Here&#8217;s an example using the MySQL database server (<code>package_file_service.pp</code>):</p>

<pre><code class="Shell">package { 'mysql-server':
  ensure =&gt; installed,
  notify =&gt; Service['mysql'],
}

file { '/etc/mysql/mysql.cnf':
  source =&gt; '/examples/files/mysql.cnf',
  notify =&gt; Service['mysql'],
}

service { 'mysql':
  ensure =&gt; running,
  enable =&gt; true,
}
</code></pre>

<p>The <code>package</code> resource makes sure the <code>mysql-server</code> package is installed.</p>

<p>The config file for MySQL is <code>/etc/mysql/mysql.cnf</code>, and we use a <code>file</code> resource to copy this file from the Puppet repo so that we can control MySQL settings.</p>

<p>Finally, the <code>service</code> resource ensures that the <code>mysql</code> service is running.</p>

<p>Which when run does this:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ sudo puppet apply /examples/package_file_service.pp
Notice: Compiled catalog for ubuntu-xenial.ocado.com in environment production in 0.57 seconds
Notice: /Stage[main]/Main/Package[mysql-server]/ensure: created
Notice: /Stage[main]/Main/File[/etc/mysql/mysql.cnf]/content: content changed '{md5}f5d3113b607567fd2ce955f4279fa9ce' to '{md5}9bb1147c6f1df1220a7467a0acb17801'
Notice: /Stage[main]/Main/Service[mysql]: Triggered 'refresh' from 2 events
Notice: Applied catalog in 19.48 seconds
</code></pre>

<p>Proven with:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ more /etc/mysql/mysql.cnf
!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/mysql.conf.d/
vagrant@ubuntu-xenial:/examples$ ps -ef | grep mysql
mysql     3340     1  0 10:58 ?        00:00:00 /usr/sbin/mysqld
vagrant   3380 27556  0 10:59 pts/0    00:00:00 grep --color=auto mysql
</code></pre>

<h5 id="notifyingalinkedresource">Notifying a linked resource</h5>

<p>You might have noticed a new attribute, called <code>notify</code>, in the <code>file</code> resource in the previous example:</p>

<pre><code class="Shell">file { '/etc/mysql/mysql.cnf':
  source =&gt; '/examples/files/mysql.cnf',
  notify =&gt; Service['mysql'],
}
</code></pre>

<p>What does this do? </p>

<p>Imagine you&#8217;ve made a change to the <code>mysql.cnf</code> file and applied this change with Puppet. </p>

<p>The updated file will be written to a disk, but because the <code>mysql</code> service is already running, it has no way of knowing that its config file has changed. </p>

<p>Therefore, your changes will not actually take effect until the service is restarted. However, Puppet can do this for you if you specify the <code>notify</code> attribute on the <code>file</code> resource. </p>

<p>The value of <code>notify</code> is the resource to notify about the change, and what that involves depends on the type of resource that&#8217;s being notified. </p>

<p>When it&#8217;s a service, the default action is to restart the service</p>

<p>Usually, with the package-file-service pattern, the file notifies the service, so whenever Puppet changes the contents of the file, it will restart the notified service to pick up the new configuration. </p>

<p>If there are several files that affect the service, they should all notify the service, and Puppet is smart enough to only restart the service once, however many dependent resources are changed.</p>

<p>The name of the resource to notify is specified as the resource type, capitalised, followed by the resource title, which is quoted and within square brackets: <code>Service['mysql’]</code>.</p>

<p>Proven with:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples/files$ cat mysql.cnf
!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/tonytest/
!includedir /etc/mysql/mysql.conf.d/
</code></pre>

<p>Which generated (chopped):</p>

<pre><code class="Shell">journalctl log for mysql:
-- Logs begin at Tue 2018-10-16 08:01:48 UTC, end at Tue 2018-10-16 11:08:19 UTC. --
Oct 16 11:06:45 ubuntu-xenial systemd[1]: Stopping MySQL Community Server...
Oct 16 11:06:47 ubuntu-xenial systemd[1]: Stopped MySQL Community Server.
Oct 16 11:06:47 ubuntu-xenial systemd[1]: Starting MySQL Community Server...
</code></pre>

<h5 id="resourceorderingwithrequire">Resource ordering with require</h5>

<p>In the package-file-service example, we declared three resources: the <code>mysql-server</code> package, the <code>/etc/mysql/mysql.cnf</code> file, and the <code>mysql</code> service. </p>

<p>If you think about it, they need to be applied in that order. Without the <code>mysql-server</code> package installed, there will be no <code>/etc/mysql/</code> directory to put the <code>mysql.cnf</code> file in. Without the package or the config file, the <code>mysql</code> service won&#8217;t be able to run.</p>

<p>A perfectly reasonable question to ask is, &#8220;Does Puppet apply resources in the same order in which they&#8217;re declared in the manifest?&#8221; The answer is usually yes, unless you explicitly specify a different order, using the <code>require</code> attribute.</p>

<p>All resources support the <code>require</code> attribute, and its value is the name of another resource declared somewhere in the manifest, specified in the same way as when using <code>notify</code>. </p>

<p>Here&#8217;s the package-file-service example again, this time with the resource ordering specified explicitly using <code>require</code> - that is <code>(package_file_service_require.pp)</code>:</p>

<pre><code class="Shell">package { 'mysql-server':
  ensure =&gt; installed,
}

file { '/etc/mysql/mysql.cnf':
  source  =&gt; '/examples/files/mysql.cnf',
  notify  =&gt; Service['mysql'],
  require =&gt; Package['mysql-server'],
}

service { 'mysql':
  ensure  =&gt; running,
  enable  =&gt; true,
  require =&gt; [Package['mysql-server'], File['/etc/mysql/mysql.cnf']],
}
</code></pre>

<p>You can see that the <code>mysql.cnf</code> resource requires the <code>mysql-server</code> package. The <code>mysql</code> service requires both the other resources, listed as an array within square brackets.</p>

<p>When resources are already in the right order, you don&#8217;t need to use <code>require</code>, as Puppet will apply the resources in the order you declare them. However, it can be useful to specify an ordering explicitly, for the benefit of those reading the code, especially when there are lots of resources in a manifest file.</p>

<p>In older versions of Puppet, resources were applied in a more or less arbitrary order, so it was much more important to express dependencies using <code>require</code>. Nowadays, you won&#8217;t need to use it very much, and you&#8217;ll mostly come across it in legacy code.</p>

<h4 id="summary">Summary</h4>

<p>In this chapter, we&#8217;ve seen how a manifest is made up of Puppet resources. You&#8217;ve learned how to use Puppet&#8217;s <code>file</code> resource to create and modify files, how to install packages using the <code>package</code> resource, and how to manage services with the <code>service</code> resource. We&#8217;ve looked at the common package-file-service pattern and seen how to use the <code>notify</code> attribute on a resource to send a message to another resource indicating that its configuration has been updated. We&#8217;ve covered the use of the <code>require</code> attribute to make dependencies between resources explicit, when necessary.</p>

<p>You&#8217;ve also learned to use <code>puppet resource</code> to inspect the current state of the system according to Puppet, and <code>puppet describe</code> to get command-line help on all Puppet resources. To check what Puppet would change on the system without actually changing it, we&#8217;ve introduced the <code>—noop</code> and <code>—show_diff</code> options to <code>puppet apply</code>.</p>

<p>In the next chapter, we&#8217;ll see how to use the version control tool Git to keep track of your manifests, we&#8217;ll get an introduction to fundamental Git concepts, such as the repo and the commit, and you&#8217;ll learn how to distribute your code to each of the servers you&#8217;re going to manage with Puppet.</p>

<h3 id="chapter3-managingyourpuppetcodewithgit">Chapter 3 - Managing your Puppet code with Git</h3>

<p>In this chapter, we’ll learn how to use the Git version control system to manage your Puppet manifests. </p>

<p>We’ll also learn how to use Git to distribute the manifests to multiple nodes, so that you can start managing your whole network with Puppet.</p>

<h4 id="whatisversioncontrol">What is version control?</h4>

<p>Even if you&#8217;re the only person who works on a piece of source code (for example, Puppet manifests), it&#8217;s still useful to be able to see what changes you made, and when. </p>

<p>For example, you might realise that you introduced a bug at some point in the past, and you need to examine exactly when a certain file was modified and exactly what the change was. </p>

<p>A version control system lets you do that, by keeping a complete history of the changes you&#8217;ve made to a set of files over time.</p>

<h5 id="trackingchanges">Tracking Changes</h5>

<p>When you&#8217;re working on code with others, you also need a way to communicate with the rest of the team about your changes. </p>

<p>A version control tool such as Git not only tracks everyone&#8217;s changes, but lets you record a <strong>commit message</strong>, explaining what you did and why. </p>

<p>The following example illustrates some aspects of a good commit message:</p>

<pre><code class="Shell">Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as
the subject of the commit and the rest of the text as the body.
The blank line separating the summary from the body is critical
(unless you omit the body entirely); various tools like `log`,
`shortlog`, and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
</code></pre>

<p>Git also records when the change happened, who made it, what files were changed, added, or deleted, and which lines were added, altered, or removed. </p>

<p>As you can imagine, if you&#8217;re trying to track down a bug, and you can see a complete history of changes to the code, that&#8217;s a big help. It also means you can, if necessary, roll back the state of the code to any point in history and examine it.</p>

<p>You might think this introduces a lot of extra complication. In fact, it&#8217;s very simple. Git keeps out of your way until you need it, and all you have to do is write a commit message when you decide to record changes to the code.</p>

<h5 id="sharingcode">Sharing Code</h5>

<p>A set of files under Git version control is called a <strong>repository</strong>, which is usually equivalent to a project. </p>

<p>A Git repository (from now on, just <strong>repo</strong>) is also a great way to distribute your code to others, whether privately or publicly, so that they can use it, modify it, contribute changes back to you, or develop it in a different direction for their own requirements. </p>

<p>The public GitHub repo for this book which we looked at in Chapter 1, _Getting started with Puppet_ is a good example of this. You&#8217;ll be able to use this repo for working through examples throughout the book, but you can also use it for help and inspiration when building Puppet manifests for your own infrastructure.</p>

<p>Because Git is so important for managing Puppet code, it&#8217;s a good idea to get familiar with it, and the only way to do that is to use it for real. So let&#8217;s start a new Git repo we can use to experiment with.</p>

<h4 id="creatingagitrepo">Creating a Git repo</h4>

<p>It&#8217;s very easy to create a Git repo. Follow these steps:</p>

<ul>
<li>Make a directory to hold your versioned files using the following commands:</li>
</ul>

<pre><code class="Shell">cd
mkdir puppet
</code></pre>

<p>Now run the following commands to turn the directory into a Git repo:</p>

<pre><code class="Shell">cd puppet
git init
Initialized empty Git repository in /home/ubuntu/puppet/.git/
</code></pre>

<p> As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ pwd
/home/vagrant
vagrant@ubuntu-xenial:~$ ls
puppet-release-xenial.deb
vagrant@ubuntu-xenial:~$ mkdir puppet
vagrant@ubuntu-xenial:~$ cd puppet
vagrant@ubuntu-xenial:~/puppet$ git init
Initialized empty Git repository in /home/vagrant/puppet/.git/
</code></pre>

<h5 id="makingyourfirstcommit">Making your first commit</h5>

<p>You can change the files in your repo as much as you like, but Git will not know about the changes until you make what&#8217;s called a <strong>commit</strong>. </p>

<p>You can think of a commit as being like a snapshot of the repo at a particular moment, but it also stores information about what changed in the repo since the previous commit. </p>

<p>Commits are stored forever, so you will always be able to roll back the repo to the state it was in at a certain commit, or show what files were changed in a past commit and compare them to the state of the repo at any other commit.</p>

<p>Let&#8217;s make our first commit to the new repo.</p>

<p>Because Git records not only changes to the code, but also who made them, it needs to know who you are. </p>

<ol>
<li>Set your identification details for Git (use your own name and email address, unless you particularly prefer mine) using the following commands:</li>
</ol>

<p><code>Shell
git config --global user.name “AJ9”
git config --global user.email anthony@junipernine.com
</code> 
2. It is traditional for Git repos to have a <strong>README</strong> file, which explains what&#8217;s in the repo and how to use it. For the moment, let&#8217;s just create this file with a placeholder message:</p>

<pre><code class="Shell">echo &quot;Watch this space... coming soon!&quot; &gt;README.md
</code></pre>

<ol>
<li>Run the following command:</li>
</ol>

<pre><code class="Shell">git status

On branch master
Initial commit
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        README.md
nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre>

<ol>
<li>Because we&#8217;ve added a new file to the repo, changes to it won&#8217;t be tracked by Git unless we explicitly tell it to. We do this by using the <code>git add</code> command, as follows:</li>
</ol>

<pre><code class="Shell">git add README.md
</code></pre>

<ol>
<li>Git now knows about this file, and changes to it will be included in the next commit. We can check this by running <code>git status</code> again:</li>
</ol>

<pre><code class="Shell">git status

On branch master
Initial commit
Changes to be committed:
  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)
        new file:   README.md
</code></pre>

<ol>
<li>The file is listed under <code>Changes to be committed</code>, so we can now actually make the commit:</li>
</ol>

<pre><code class="Shell">git commit -m 'Add README file'

[master (root-commit) ee21595] Add README file
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
</code></pre>

<p><strong>NB.</strong> The -m allows you to add the commit message on the command line rather than being put into a vi editor to apply it.</p>

<ol>
<li>You can always see the complete history of commits in a repo by using the <code>git log</code> command.</li>
</ol>

<p>Run this now to see the commit you just made:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~/puppet$ git log
commit 48522513039084b24cbddc9b8245f456acfe1f5a
Author: AJ9 &lt;anthony@junipernine.com&gt;
Date:   Tue Oct 16 12:32:04 2018 +0000

    Add README file
</code></pre>

<h5 id="howoftenshouldicommit">How often should I commit</h5>

<p>A common practice is to commit when the code is in a consistent, working state, and have the commit include a set of related changes made for some particular purpose. </p>

<p>So, for example, if you are working to fix bug number 75 in your issue-tracking system, you might make changes to quite a few separate files and then, once you&#8217;re happy the work is complete, make a single commit.</p>

<p>On the other hand, if you are making a large number of complicated changes and you are not sure when you&#8217;ll be done, it might be wise to make a few separate commits along the way, so that if necessary you can roll the code back to a previous state. </p>

<p>Commits cost nothing, so when you feel a commit is needed, go ahead and make it.</p>

<h5 id="branching">Branching</h5>

<p>Git has a powerful feature called <strong>branching</strong>, which lets you create a parallel copy of the code (a branch) and make changes to it independently. </p>

<p>At any time, you can choose to merge those changes back into the master branch. Or, if changes have been made to the master branch in the meantime, you can incorporate those into your working branch and carry on.</p>

<p>This is extremely useful when working with Puppet, because it means you can switch a single node to your branch while you&#8217;re testing it and working on it. </p>

<p>The changes you make won&#8217;t be visible to other nodes which aren&#8217;t on your branch, so there&#8217;s no danger of accidentally rolling out changes before you&#8217;re ready.</p>

<p>Once you&#8217;re done, you can merge your changes back into master and have them roll out to all nodes.</p>

<p>Similarly, two or more people can work independently on their own branches, exchanging individual commits with each other and with the master branch as they choose. This is a very flexible and useful way of working.</p>

<p>Check out the Git Tutorial for more info.</p>

<h4 id="distributingpuppetmanifests">Distributing Puppet manifests</h4>

<p>So far we&#8217;ve only applied Puppet manifests to one node, using <code>puppet apply</code> with a local copy of the manifest. </p>

<p>To manage several nodes at once, we need to distribute the Puppet manifests to each node so that they can be applied.</p>

<p>There are several ways to do this, and as we saw in Chapter 1, _Getting started with Puppet_ one approach is to use the <strong>agent/master</strong> architecture, where a central Puppet master server compiles your manifests and distributes the <strong>catalog</strong> (the desired node state) to all nodes.</p>

<p>Another way to use Puppet is to do without the master server altogether, and use Git to distribute manifests to client nodes, which then runs <code>puppet apply</code> to update their configuration. This <strong>stand-alone</strong> Puppet architecture doesn&#8217;t require a dedicated Puppet master server, and there&#8217;s no single point of failure.</p>

<p>Both agent/master and stand-alone architectures are officially supported by Puppet, and it&#8217;s possible to change from one to the other if you decide you need to. The examples in this book were developed with the stand-alone architecture, but will work just as well with agent/master if you prefer it. </p>

<p>There is no difference in the Puppet manifests, language, or structure; the only difference is in the way the manifests are applied.</p>

<p>All you need for a stand-alone Puppet architecture is a Git server which each node can connect to and clone the repo. </p>

<p>You can run your own Git server if you like, or use a public Git hosting service such as GitHub. For ease of explanation, I&#8217;m going to use GitHub for this example setup.</p>

<p>In the following sections, we&#8217;ll create a GitHub account, push our new Puppet repo to GitHub, and then set up our virtual machine to automatically pull any changes from the GitHub repo and apply them with Puppet.</p>

<h4 id="creatingagithubaccountandproject">Creating a GitHub account and project</h4>

<ul>
<li>Browse to https://github.com/</li>
<li>Start a new Project</li>
<li>Call it ‘puppet’ or something like that</li>
<li>Click <strong>Create repository</strong></li>
</ul>

<h4 id="pushingyourrepotogithub">Pushing your repo to GitHub</h4>

<p>Git was designed to support a more distributed model with no need for a central repository.Git was designed so that people on an unreliable link could exchange code via email, even. In order to support this model git maintains a local repository with your code and also an additional local repository that mirrors the state of the remote repository. By keeping a copy of the remote repository locally, git can figure out the changes needed even when the remote repository is not reachable. Later when you need to send the changes to someone else, git can transfer them as a set of changes from a point in time known to the remote repository.</p>

<h5 id="gitfetch">Git fetch</h5>

<pre><code class="Shell">$ git fetch origin
</code></pre>

<p><strong>git fetch</strong> only downloads new data from a remote repository – but it doesn’t integrate any of this new data into working files/directory. Fetch is good for getting a fresh view on all the things that happened in a remote repository. It is harmless and doesnt manipulate local changes.</p>

<h5 id="gitpull">Git Pull</h5>

<pre><code class="Shell">$ git pull origin master
</code></pre>

<p>git pull does a git fetch followed by a git merge. Since “git pull” tries to merge remote changes with your local ones, a so-called “merge conflict” can occur. It’s highly recommended to start a “git pull” only with a clean working copy.</p>

<h5 id="gitclone">Git clone</h5>

<pre><code class="Shell">$git clone git@github.com:whatever/something.git
</code></pre>

<p>Git clone will clone a repo int a newly created directory. Git clone additionally creates a remote called ‘origin’ for the repo cloned from, sets up a local branch based on the remote’s active branch (generally master), and creates remote-tracking branches for all the branches in the repo</p>

<pre><code class="Shell">git clone https://github.com/junipernineaj/puppet-reeducation.git
vi README.md
git add README.md
git commit -m &quot;New File&quot;
</code></pre>

<h4 id="cloningtherepo">Cloning the repo</h4>

<p>In order to manage multiple nodes with Puppet, you will need a copy of the repo on each node. If you have a node you&#8217;d like to manage with Puppet, you can use it in this example. Otherwise, use the Vagrant box we&#8217;ve been working with in previous chapters.</p>

<p>Run the following commands (replace the argument to <code>git clone</code> with the URL of your own GitHub repo, but don&#8217;t lose the <code>production</code> at the end):</p>

<pre><code class="Shell">cd /etc/puppetlabs/code/environments
sudo mv production production.sample
sudo git clone https://github.com/junipernineaj/puppet-reeducation.git production


Cloning into 'production'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
Checking connectivity... done.
</code></pre>

<p>How does this work? </p>

<p>The standard place for Puppet manifests in a production environment is the <code>/etc/puppetlabs/code/environments/production/</code> directory, so that&#8217;s where our cloned repo needs to end up. </p>

<p>However, the Puppet package installs some sample manifests in that directory, and Git will refuse to clone into a directory that already exists, so we move that directory out of the way with the <code>mv production production.sample</code> command. </p>

<p>The <code>git clone</code> command then recreates that directory, but this time it contains our manifests from the repo.</p>

<h4 id="fetchingandapplyingchangesautomatically">Fetching and applying changes automatically</h4>

<p>In a stand-alone Puppet architecture, each node needs to automatically fetch any changes from the Git repo at regular intervals, and apply them with Puppet. </p>

<p>We can use a simple shell script for this, and there&#8217;s one in the example repo (<code>/examples/files/run-puppet.sh</code>):</p>

<pre><code class="Shell">#!/bin/bash
cd /etc/puppetlabs/code/environments/production &amp;&amp; git pull
/opt/puppetlabs/bin/puppet apply manifests/
</code></pre>

<p>We will need to install this script on the node to be managed by Puppet, and create a cron job to run it regularly (I suggest every 15 minutes). </p>

<p>Of course, we could do this work manually, but isn&#8217;t this book partly about the advantages of automation? Very well, then: let&#8217;s practice what we&#8217;re preaching.</p>

<p>Example:</p>

<pre><code class="Shell">  219  sudo vi ssh_authorized_key.pp
  220  ls -ltr
  221  sudo git add ssh_authorized_key.pp
  222  sudo git commit -m &quot;Update email in ssh authorised key file&quot;
  223  git status
  224  sudo git push
</code></pre>

<h5 id="writingamanifesttosetupregularpuppetruns">Writing a manifest to set up regular Puppet runs</h5>

<p>In this section, we&#8217;ll create the necessary Puppet manifests to install the <code>run-puppet</code> script on a node and run it regularly from cron:</p>

<ol>
<li>Run the following commands to create the required directories in your Puppet repo:</li>
</ol>

<pre><code class="Shell">su - ubuntu 
cd /home/ubuntu/puppet
sudo mkdir manifests files
</code></pre>

<ol>
<li>Run the following command to copy the <code>run-puppet</code> script from the <code>examples/</code> directory:</li>
</ol>

<p><code>Shell
cp /examples/files/run-puppet.sh files/
</code>  3. Run the following command to copy the <code>run-puppet</code> manifest from the <code>examples/</code> directory:</p>

<pre><code class="Shell">cp /examples/run-puppet.pp manifests/
</code></pre>

<ol>
<li>Add and commit the files to Git with the following commands:</li>
</ol>

<pre><code class="Shell">git add manifests files
git commit -m 'Add run-puppet script and cron job'
git push origin master
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~/puppet-reeducation$ sudo git add manifests files

vagrant@ubuntu-xenial:~/puppet-reeducation$ sudo git commit -m 'Add run-puppet script and cron job'
[master d782159] Add run-puppet script and cron job
 2 files changed, 14 insertions(+)
 create mode 100755 files/run-puppet.sh
 create mode 100644 manifests/run-puppet.pp

vagrant@ubuntu-xenial:~/puppet-reeducation$ sudo git push origin master
Username for 'https://github.com': junipernineaj
Password for 'https://junipernineaj@github.com':
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 692 bytes | 0 bytes/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To https://github.com/junipernineaj/puppet-reeducation.git
   d8716d4..d782159  master -&gt; master
</code></pre>

<p>Your Git repo now contains everything you need to automatically pull and apply changes on your managed nodes. In the next section, we&#8217;ll see how to set up this process on a node.</p>

<p>You might have noticed that every time you push files to your GitHub repo, Git prompts you for your username and password. </p>

<p>If you want to avoid this, you can associate an SSH key with your GitHub account. </p>

<p>Once you&#8217;ve done this, you&#8217;ll be able to push without having to re-enter your credentials every time. </p>

<p>For more information about using an SSH key with your GitHub account see this article:</p>

<p>https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</p>

<h5 id="applyingtherun-puppetmanifest">Applying the run-puppet manifest</h5>

<p>Having created and pushed the manifest necessary to set up automatic Puppet runs, we now need to pull and apply it on the target node.</p>

<p>In the cloned copy of your repo in <code>/etc/puppetlabs/code/environments/production</code>, run the following commands:</p>

<pre><code class="Shell">sudo git pull
sudo puppet apply manifests/
Notice: Compiled catalog for localhost in environment production in 0.08 seconds
Notice: /Stage[main]/Main/File[/usr/local/bin/run-puppet]/ensure: defined content as '{md5}83a6903e69564bcecc8fd1a83b1a7beb'
Notice: /Stage[main]/Main/Cron[run-puppet]/ensure: created
Notice: Applied catalog in 0.07 seconds
</code></pre>

<p>My output:</p>

<pre><code class="Shell">ubuntu@ubuntu-xenial:/etc/puppetlabs/code/environments/production$ sudo puppet apply manifests/
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.04 seconds
Notice: /Stage[main]/Main/File[/usr/local/bin/run-puppet]/ensure: defined content as '{md5}dbfba978957e90ebb47e3a266b89231b'
Notice: /Stage[main]/Main/Cron[run-puppet]/ensure: created
Notice: Applied catalog in 0.06 seconds
</code></pre>

<p>You can see from Puppet&#8217;s output that it has created the <code>/usr/local/bin/run-puppet</code> script and the <code>run-puppet</code> cron job. </p>

<p>This will now run automatically every 15 minutes, pull any new changes from the Git repo, and apply the updated manifest.</p>

<p><strong>NB.</strong> They will be put in the <code>root</code> crontab.</p>

<p>If you run this from <code>/home/ubuntu</code> you get:</p>

<pre><code class="Shell">ubuntu@ubuntu-xenial:~/puppet$ sudo puppet apply manifests/
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.04 seconds
Notice: Applied catalog in 0.04 seconds
</code></pre>

<p>The same.</p>

<p>Here is the crontab:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/home/ubuntu$ sudo crontab -l
# HEADER: This file was autogenerated at 2018-10-17 10:39:06 +0000 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: run-puppet
*/15 * * * * /usr/local/bin/run-puppet
</code></pre>

<p>Here is the script in <code>/usr/local/bin</code></p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/home/ubuntu$ cd /usr/local/bin
vagrant@ubuntu-xenial:/usr/local/bin$ ls
run-puppet
vagrant@ubuntu-xenial:/usr/local/bin$ ls -l
total 4
-rwxr-xr-x 1 root root 116 Oct 17 10:39 run-puppet
</code></pre>

<h5 id="therun-puppetscript">The run-puppet script</h5>

<p>The <code>run-puppet</code> script does the following two things in order to automatically update the target node:</p>

<ul>
<li>Pull any changes from the Git server (<code>git pull</code>)</li>
<li>Apply the manifest (<code>puppet apply</code>)</li>
</ul>

<p>Our Puppet manifest in <code>run-puppet.pp</code> deploys this script to the target node, using a <code>file</code> resource, and then sets up a cron job to run it every 15 minutes, using a <code>cron</code> resource. </p>

<p>We haven&#8217;t met the <code>cron</code> resource before, but we will cover it in more detail in <em>Understanding Puppet resources</em>`.</p>

<p>For now, just note that the cron resource has a name (<code>run-puppet</code>), which is just for the benefit of us humans, to remind us what it does, and it also has a <code>command</code> to run and <code>hour</code> and <code>minute</code> attributes to control when it runs. </p>

<p>The value <code>*/15</code> tells <code>cron</code> to run the job every 15 minutes.</p>

<h5 id="testingautomaticpuppetruns">Testing automatic Puppet runs</h5>

<p>To prove that the automatic Puppet run works, make a change to your manifest which creates a file (<code>/tmp/hello.txt</code>, for example). </p>

<p>Commit and push this change to Git. Wait 15 minutes, and check your target node. </p>

<pre><code class="Shell">git status
git commit -a -m “blah”
</code></pre>

<p>Then distribute it.</p>

<pre><code class="Shell">git push ##to get it to your remote
</code></pre>

<p>The file should be present. If not, something is broken. </p>

<p>To troubleshoot the problem, try running <code>sudo run-puppet</code> manually. </p>

<p>If this works, check that the cron job is correctly installed by running <code>sudo crontab -l</code>. </p>

<p>It should look something like the following:</p>

<pre><code class="Shell"># HEADER: This file was autogenerated at 2017-04-05 01:46:03 -0700 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: run-puppet
*/15 * * * * /usr/local/bin/run-puppet
</code></pre>

<h5 id="managingmultiplefiles">Managing multiple files</h5>

<p>We now have a fully automated stand-alone Puppet infrastructure. </p>

<p>Any change that we check in to our Git repo will be automatically applied to all nodes under Puppet management. To add more nodes to your infrastructure, follow these steps for each new node:</p>

<ul>
<li>Install Puppet (not necessary if you&#8217;re using the Vagrant box).</li>
<li>Clone your Git repo (as described in the Cloning the repo section).</li>
<li>Apply the manifest (as described in the Applying the run-puppet manifest section).</li>
</ul>

<p>You might be wondering how to tell Puppet how to apply different manifests to different nodes. </p>

<p>For example, you might be managing two nodes, one of which is a web server and the other a database server. Naturally, they will need different resources.</p>

<p>We&#8217;ll learn more about nodes and how to control the application of resources to different nodes in Classes, roles, and profiles. </p>

<p>But first, we need to learn about Puppet&#8217;s resources and how to use them. </p>

<p>We&#8217;ll do that in the next chapter.</p>

<h5 id="summary">Summary</h5>

<p>In this chapter, we introduced the concepts of version control, and the essentials of Git in particular. </p>

<p>We set up a new Git repo, created a GitHub account, pushed our code to it, and cloned it on a node. </p>

<p>We wrote a shell script to automatically pull and apply changes from the GitHub repo on any node, and a Puppet manifest to install this script and run it regularly from <code>cron</code>.</p>

<p>In the next chapter, we&#8217;ll explore the power of Puppet resources, going into more detail about the Puppet <code>file</code>, <code>package</code>, and <code>service</code> resources we&#8217;ve already encountered, and introducing three more important resource types: <code>user</code>, <code>cron</code>, and <code>exec</code>.</p>

<h3 id="chapter4-understandingpuppetresources">Chapter 4 - Understanding Puppet Resources</h3>

<p>We&#8217;ve already met three important types of Puppet resources: <code>package</code>, <code>file</code>, and <code>service</code>. </p>

<p>In this chapter, we&#8217;ll learn more about these, plus other important resource types for managing users, groups, SSH keys, cron jobs, and arbitrary commands.</p>

<h4 id="files">Files</h4>

<p>We saw in _Chapter 2, Creating your first manifests_ that Puppet can manage files on a node using the <code>file</code> resource, and we looked at an example which sets the contents of a file to a particular string using the <code>content</code> attribute. Here it is again <code>(file_hello.pp)</code>:</p>

<pre><code class="Shell">file { '/tmp/hello.txt':
  content =&gt; &quot;hello, world\n&quot;,
}
</code></pre>

<h5 id="thepathattribute">The path attribute</h5>

<p>We&#8217;ve seen that every Puppet resource has a title (a quoted string followed by a colon). In the <code>file_hello</code> example, the title of the <code>file</code> resource is ‘<code>/tmp/hello.txt</code>’. </p>

<p>It&#8217;s easy to guess that Puppet is going to use this value as the path of the created file. In fact, <code>path</code> is one of the attributes you can specify for a <code>file</code>, but if you don&#8217;t specify it, Puppet will use the title of the resource as the value of <code>path</code>.</p>

<h5 id="managingwholefiles">Managing whole files</h5>

<p>While it&#8217;s useful to be able to set the contents of a file to a short text string, most files we&#8217;re likely to want to manage will be too large to include directly in our Puppet manifests. </p>

<p>Ideally, we would put a copy of the file in the Puppet repo, and have Puppet simply copy it to the desired place in the filesystem. </p>

<p>The <code>source</code> attribute does exactly that (<code>file_source.pp</code>):</p>

<pre><code class="Shell">file { '/etc/motd':
  source =&gt; '/examples/files/motd.txt',
}
</code></pre>

<p>To try this example with your Vagrant box, run the following commands:</p>

<pre><code class="Shell">sudo puppet apply /examples/file_source.pp
cat /etc/motd
The best software in the world only sucks. The worst software is significantly worse than that.
-Luke Kanies
</code></pre>

<p>Which does this:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples/files$ sudo puppet apply /examples/file_source.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.02 seconds
Notice: /Stage[main]/Main/File[/etc/motd]/ensure: defined content as '{md5}2400ab50861ff84ea5a3e43126d162d5'
Notice: Applied catalog in 0.12 seconds
</code></pre>

<p>(From now on, I won&#8217;t give you explicit instructions on how to run the examples; just apply them in the same way using <code>sudo puppet apply</code> as shown here. </p>

<p>All the examples in this book are in the <code>examples/</code> directory of the GitHub repo, and I&#8217;ll give you the name of the appropriate file for each example, such as <code>file_source.pp</code>.)</p>

<p>BUT:</p>

<p>Why do we have to run <code>sudo puppet apply</code> instead of just <code>puppet apply</code>? </p>

<p>Puppet has the permissions of the user who runs it, so if Puppet needs to modify a file owned by <code>root</code>, it must be run with <code>root</code>’s permissions (which is what <code>sudo</code> does). </p>

<p>You will usually run Puppet as <code>root</code> because it needs those permissions to do things like installing packages, modifying config files owned by <code>root</code>, and so on.</p>

<p>The value of the <code>source</code> attribute can be a path to a file on the node, as here, or an HTTP URL, as in the following example (<code>file_http.pp</code>):</p>

<pre><code class="Shell">file { '/tmp/README.md':
  source =&gt; 'https://raw.githubusercontent.com/puppetlabs/puppet/master/README.md',
}
</code></pre>

<p>Although this is a handy feature, bear in mind that every time you add an external dependency like this to your Puppet manifest, you&#8217;re adding a potential point of failure.</p>

<p>Wherever you can, use a local copy of a file instead of having Puppet fetch it remotely every time. This particularly applies to software which needs to be built from a tarball downloaded from a website. </p>

<p>If possible, download the tarball and serve it from a local webserver or file server. If this isn&#8217;t practical, using a caching proxy server can help save time and bandwidth when you&#8217;re building a large number of nodes.</p>

<h5 id="ownership">Ownership</h5>

<p>On Unix-like systems, files are associated with an <strong>owner</strong>, a <strong>group</strong>, and a set of <strong>permissions</strong> to read, write, or execute the file. Since we normally run Puppet with the permissions of the <code>root</code> user (via <code>sudo</code>), the files Puppet manages will be owned by that user:</p>

<pre><code class="Shell">ls -l /etc/motd
-rw-r--r-- 1 root root 109 Aug 31 04:03 /etc/motd
</code></pre>

<p>Often, this is just fine, but if we need the file to belong to another user (for example, if that user needs to be able to write to the file), we can express this by setting the <code>owner</code> attribute (file_owner.pp):</p>

<pre><code class="Shell">file { '/etc/owned_by_ubuntu':
  ensure =&gt; present,
  owner  =&gt; 'ubuntu',
}

vagrant@ubuntu-xenial:~$ sudo puppet apply /examples/file_owner.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.04 seconds
Notice: /Stage[main]/Main/File[/etc/owned_by_ubuntu]/ensure: created
Notice: Applied catalog in 0.03 seconds
vagrant@ubuntu-xenial:~$

ls -l /etc/owned_by_ubuntu
-rw-r--r-- 1 ubuntu root 0 Aug 31 04:48 /etc/owned_by_ubuntu

</code></pre>

<p>You can see that Puppet has created the file and its owner has been set to <code>ubuntu</code>. You can also set the group ownership of the file using the <code>group</code> attribute (<code>file_group.pp</code>):</p>

<pre><code class="Shell">file { '/etc/owned_by_ubuntu':
  ensure =&gt; present,
  owner  =&gt; 'ubuntu',
  group  =&gt; 'ubuntu',
}

ls -l /etc/owned_by_ubuntu
-rw-r--r-- 1 ubuntu ubuntu 0 Aug 31 04:48 /etc/owned_by_ubuntu
</code></pre>

<p>Note that this time we didn&#8217;t specify either a <code>content</code> or <code>source</code> attribute for the file, but simply <code>ensure =&gt; present</code>. </p>

<p>In this case, Puppet will create a file of zero size.</p>

<h5 id="permissions">Permissions</h5>

<p>Files on Unix-like systems have an associated <strong>mode</strong> which determines access permissions for the file. It governs read, write, and execute permissions for the file&#8217;s owner, any user in the file&#8217;s group, and other users. </p>

<p>Puppet supports setting permissions on files using the <code>mode</code> attribute. This takes an octal value (base 8, indicated by a leading 0 digit), with each digit representing a field of 3 binary bits: the permissions for owner, group, and other, respectively.
In the following example, we use the <code>mode</code> attribute to set a mode of <code>0644</code> (&#8220;read and write for the owner, read-only for the group, and read-only for other users&#8221;) on a file (<code>file_mode.pp</code>):</p>

<pre><code class="Shell">file { '/etc/owned_by_ubuntu':
  ensure =&gt; present,
  owner  =&gt; 'ubuntu',
  mode   =&gt; '0644',
}

</code></pre>

<p>Resulting in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/examples$ ls -l /etc/owned_by_ubuntu
-rw-r--r-- 1 ubuntu ubuntu 0 Oct 17 16:19 /etc/owned_by_ubuntu
</code></pre>

<p>This will be quite familiar to experienced system administrators, as the octal values for file permissions are exactly the same as those understood by the Unix <code>chmod</code> command. </p>

<p>For more information, run the command <code>man chmod</code>.</p>

<h5 id="directories">Directories</h5>

<p>Creating or managing permissions on a <strong>directory</strong> is a common task, and Puppet uses the <code>file</code> resource to do this too. </p>

<p>If the value of the <code>ensure</code> attribute is <code>directory</code>, the file will be a directory (<code>file_directory.pp</code>):</p>

<pre><code class="Shell">file { '/etc/config_dir':
  ensure =&gt; directory,
}
</code></pre>

<p>As with regular files, you can use the <code>owner</code>, <code>group</code>, and <code>mode</code> attributes to control access to directories.</p>

<h5 id="treesoffiles">Trees of Files</h5>

<p>We&#8217;ve already seen that Puppet can copy a single file to the node, but what about a whole directory of files, possibly including subdirectories (known as a <strong>file tree</strong>)?</p>

<p>The recurse attribute will take care of this (<code>file_tree.pp</code>):</p>

<pre><code class="Shell">file { '/etc/config_dir':
  source  =&gt; '/examples/files/config_dir',
  recurse =&gt; true,
}

ls /etc/config_dir/
1  2  3
</code></pre>

<p>When <code>recurse</code> is <code>true</code>, Puppet will copy all the files and directories (and their subdirectories) in the source directory (<code>/examples/files/config_dir/</code> in this example) to the target directory (<code>/etc/config_dir/</code>).
If the target directory already exists and has files in it, Puppet will not interfere with them, but you can change this behaviour using the <code>purge</code> attribute. </p>

<p>If this is <code>true</code>, Puppet will delete any files and directories in the target directory which are not present in the source directory. Use this attribute with care.</p>

<h5 id="symboliclinks">Symbolic Links</h5>

<p>Another common requirement for managing files is to create or modify a <strong>symbolic link</strong> (known as a <strong>symlink</strong>, for short). You can have Puppet do this by setting <code>ensure =&gt; link</code> on the <code>file</code> resource and specifying the <code>target</code> attribute (<code>file_symlink.pp</code>):</p>

<pre><code class="Shell">file { '/etc/this_is_a_link':
  ensure =&gt; link,
  target =&gt; '/etc/motd',
}

ls -l /etc/this_is_a_link
lrwxrwxrwx 1 root root 9 Aug 31 05:05 /etc/this_is_a_link -&gt; /etc/motd
</code></pre>

<h4 id="packages">Packages</h4>

<p>We&#8217;ve already seen how to install a package using the <code>package</code> resource, and this is all you need to do with most packages. </p>

<p>As a recap, all resource declarations in Puppet follow this form:</p>

<pre><code class="Shell">RESOURCE_TYPE { TITLE:
  ATTRIBUTE =&gt; VALUE,
  ...
}
</code></pre>

<p><code>package</code> resources are no different. The <code>RESOURCE_TYPE</code> is <code>package</code>, and the only attribute you usually need to specify is <code>ensure</code>, and the only value it usually needs to take is <code>installed</code>:</p>

<pre><code class="Shell">package { 'cowsay':
  ensure =&gt; installed,
}
</code></pre>

<p>However, the <code>package</code> resource has a few extra features which may be useful.</p>

<h5 id="uninstallingpackages">Uninstalling packages</h5>

<p>The <code>ensure</code> attribute normally takes the value <code>installed</code> in order to install a package, but if you specify <code>absent</code> instead, Puppet will <strong>remove</strong> the package if it happens to be installed. Otherwise, it will take no action. </p>

<p>The following example will remove the <code>apparmor</code> package if it&#8217;s installed (<code>package_remove.pp</code>):</p>

<pre><code class="Shell">package { 'apparmor':
  ensure =&gt; absent,
}
</code></pre>

<p>By default, when Puppet removes packages, it leaves in place any files managed by the package. To purge all the files associated with the package, use <code>purged</code> instead of <code>absent</code>.</p>

<h5 id="installingspecificversions">Installing Specific Versions</h5>

<p>If there are multiple versions of a package available to the system&#8217;s package manager, specifying <code>ensure =&gt; installed</code> will cause Puppet to install the default version (usually the latest). </p>

<p>But, if you need a specific version, you can specify that version string as the value of <code>ensure</code>, and Puppet will install that version (<code>package_version.pp</code>):</p>

<pre><code class="Shell">package { 'openssl':
  ensure =&gt; '1.0.2g-1ubuntu4.8',
}
</code></pre>

<p>It&#8217;s a good idea to specify an exact version whenever you manage packages with Puppet, so that all the nodes will get the same version of a given package. </p>

<p>Otherwise, if you use <code>ensure =&gt; installed</code>, they will just get whatever version was current at the time they were built, leading to a situation where different nodes have different package versions.</p>

<p>When a newer version of the package is released, and you decide it&#8217;s time to upgrade to it, you can update the version string specified in the Puppet manifest and Puppet will upgrade the package everywhere.</p>

<h5 id="installingthelatestversion">Installing the Latest Version</h5>

<p>On the other hand, if you specify <code>ensure =&gt; latest</code> for a package, Puppet will make sure that the latest available version is installed <em>every time the manifest is applied</em>. </p>

<p>When a new version of the package becomes available, it will be installed automatically on the next Puppet run.</p>

<p>This is not generally what you want when using a package repository that&#8217;s not under your control (for example, the main Ubuntu repository). It means that packages will be upgraded at unexpected times, which may break your application (or at least result in unplanned downtime). </p>

<p>A better strategy is to tell Puppet to install a specific version which you know works, and test upgrades in a controlled environment before rolling them out to production.</p>

<p>If you maintain your own package repository and control the release of new packages to it, <code>ensure =&gt; latest</code> can be a useful feature: Puppet will update a package as soon as you push a new version to the repo. If you are relying on upstream repositories, such as the Ubuntu repositories, it&#8217;s better to manage the version number directly by specifying an explicit version as the value of <code>ensure</code>.</p>

<p>http://manpages.ubuntu.com/manpages/bionic/man1/version.1ssl.html</p>

<h5 id="installingrubygems">Installing Ruby Gems</h5>

<p>Although the <code>package</code> resource is most often used to install packages using the normal system package manager (in the case of Ubuntu, that&#8217;s APT), it can install other kinds of packages as well. </p>

<p>Library packages for the Ruby programming language are known as <strong>gems</strong>. Puppet can install Ruby gems for you using the <code>provider =&gt; gem</code> attribute (<code>package_gem.pp</code>):</p>

<pre><code class="Shell">package { 'ruby':
  ensure =&gt; installed,
}

package { 'puppet-lint':
  ensure   =&gt; installed,
  provider =&gt; gem,
}
</code></pre>

<p>Resulting in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ sudo puppet apply /examples/package_gem.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.45 seconds
Notice: /Stage[main]/Main/Package[ruby]/ensure: created
Notice: /Stage[main]/Main/Package[puppet-lint]/ensure: created
Notice: Applied catalog in 6.31 seconds
</code></pre>

<p><code>puppet-lint</code> is a Ruby gem and therefore we have to specify <code>provider =&gt; gem</code> for this package so that Puppet doesn&#8217;t think it&#8217;s a standard system package and try to install it via APT. </p>

<p>Since the <code>gem</code> provider is not available unless Ruby is installed, we install the <code>ruby</code> package first, then the <code>puppet-lint</code> gem.</p>

<p>http://puppet-lint.com/checks/</p>

<p>The <code>puppet-lint</code> tool, by the way, is a good thing to have installed. It will check your Puppet manifests for common style errors and make sure they comply with the official Puppet style guide. </p>

<p>Try it now:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ puppet-lint /examples/lint_test.pp

WARNING: indentation of =&gt; is not properly aligned (expected in column 11, but found it in column 10) on line 2
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ more /examples/lint_test.pp
file { '/tmp/lint.txt':
  ensure =&gt; file,
  content =&gt; &quot;puppet-lint is your friend\n&quot;,
}
</code></pre>

<p>In this example, <code>puppet-lint</code> is warning you that the <code>=&gt;</code> arrows are not lined up vertically, which the style guide says they should be:
When <code>puppet-lint</code> produces no output, the file is free of lint errors.</p>

<p>You can fix this with the <code>--fix</code> flag:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ puppet-lint --fix /examples/lint_test.pp
FIXED: indentation of =&gt; is not properly aligned (expected in column 11, but found it in column 10) on line 2
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ more /examples/lint_test.pp
file { '/tmp/lint.txt':
  ensure  =&gt; file,
  content =&gt; &quot;puppet-lint is your friend\n&quot;,
}
</code></pre>

<h5 id="installinggemsinpuppetscontext">Installing Gems in Puppet&#8217;s Context</h5>

<p>Puppet itself is written at least partly in Ruby, and makes use of several Ruby gems. </p>

<p>To avoid any conflicts with the version of Ruby and gems which the node might need for other applications, Puppet packages its own version of Ruby and associated gems under the <code>/opt/puppetlabs/</code> directory. This means you can install (or remove) whichever system version of Ruby you like and Puppet will not be affected.</p>

<p>However, if you need to install a gem to extend Puppet&#8217;s capabilities in some way, then doing it with a <code>package</code> resource and <code>provider =&gt; gem</code> won&#8217;t work. That is, the gem will be installed, but only in the system Ruby context, and it won&#8217;t be visible to Puppet.</p>

<p>Fortunately, the <code>puppet_gem</code> provider is available for exactly this purpose. When you use this provider, the gem will be installed in Puppet&#8217;s context (and, naturally, won&#8217;t be visible in the system context). The following example demonstrates how to use this provider (<code>package_puppet_gem.pp</code>):</p>

<pre><code class="Shell">package { 'r10k':
  ensure   =&gt; installed,
  provider =&gt; puppet_gem,
}
</code></pre>

<p>Which did:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ sudo puppet apply /examples/package_puppet_gem.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.42 seconds
Notice: Applied catalog in 0.17 seconds
</code></pre>

<p>To see the gems installed in Puppet&#8217;s context, use Puppet&#8217;s own version of the <code>gem</code> command with the following path:</p>

<pre><code class="Shell">/opt/puppetlabs/puppet/bin/gem list
</code></pre>

<p>Which produces:</p>

<pre><code class="Shell">** LOCAL GEMS ***

bigdecimal (default: 1.3.4)
cmath (default: 1.0.0)
colored (1.2)
cri (2.15.1)
csv (default: 1.0.0)
date (default: 1.0.0)
deep_merge (1.0.1)
did_you_mean (1.2.0)
…
..
</code></pre>

<h5 id="usingensurepackages">Using Ensure packages</h5>

<p>To avoid potential package conflicts between different parts of your Puppet code or between your code and third-party modules, the Puppet standard library provides a useful wrapper for the <code>package</code> resource, called <code>ensure_packages()</code>. </p>

<p>We&#8217;ll cover this in detail in Chapter 7, <em>Mastering modules</em>.</p>

<h4 id="services">Services</h4>

<p>Although services are implemented in a number of varied and complicated ways at the operating system level, Puppet does a good job of abstracting away most of this with the <code>service</code> resource and exposing just the two attributes of services which you most commonly need to manage: whether they&#8217;re running (<code>ensure</code>) and whether they start at boot time (<code>enable</code>). </p>

<p>We covered the use of these in Chapter 2, <em>Creating your first manifests</em>, and most of the time, you won&#8217;t need to know any more about <code>service</code> resources.</p>

<p>However, you&#8217;ll occasionally encounter services which don&#8217;t play well with Puppet, for a variety of reasons. </p>

<p>Sometimes, Puppet is unable to detect that the service is already running and keeps trying to start it. Other times, Puppet may not be able to properly restart the service when a dependent resource changes. </p>

<p>There are a few useful attributes for <code>service</code> resources which can help resolve these problems.</p>

<h5 id="thehasstatusattribute">The hasstatus attribute</h5>

<p>When a <code>service</code> resource has the attribute <code>ensure =&gt; running</code> attribute, Puppet needs to be able to check whether the service is, in fact, running. The way it does this depends on the underlying operating system. </p>

<p>On Ubuntu 16 and later, for example, it runs <code>systemctl is-active SERVICE</code>. </p>

<p>If the service is packaged to work with <code>systemd</code>, that should be just fine, but in many cases, particularly with older software, it may not respond properly.</p>

<p>If you find that Puppet keeps attempting to start the service on every Puppet run, even though the service is running, it may be that Puppet&#8217;s default service status detection isn&#8217;t working. In this case, you can specify the <code>hasstatus =&gt; false</code> attribute for the service (<code>service_hasstatus.pp</code>):</p>

<pre><code class="Shell">service { 'ntp':
  ensure    =&gt; running,
  enable    =&gt; true,
  hasstatus =&gt; false,
}
</code></pre>

<p>Which does:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ sudo puppet apply /examples/service_hasstatus.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.65 seconds
Notice: /Stage[main]/Main/Package[ntp]/ensure: created
Notice: Applied catalog in 4.73 seconds
</code></pre>

<p>When <code>hasstatus</code> is false, Puppet knows not to try to check the service status using the default system service management command, and instead, will look in the process table for a running process which matches the name of the service. </p>

<p>If it finds one, it will infer that the service is running and take no further action.</p>

<h5 id="thepatternattribute">The pattern attribute</h5>

<p>Sometimes, when using <code>hasstatus =&gt; false</code>, the service name as defined in Puppet doesn&#8217;t actually appear in the process table, because the command that provides the service has a different name. </p>

<p>If this is the case, you can tell Puppet exactly what to look for using the <code>pattern</code> attribute.</p>

<p>If <code>hasstatus</code> is <code>false</code> and <code>pattern</code> is specified, Puppet will search for the value of <code>pattern</code> in the process table to determine whether or not the service is running. </p>

<p>To find the pattern you need, you can use the <code>ps</code> command to see the list of running processes:</p>

<pre><code class="Shell">ps ax
</code></pre>

<p>Find the process you&#8217;re interested in and pick a string which will match only the name of that process. For example, if it&#8217;s <code>ntpd</code>, you might specify the <code>pattern</code> attribute as <code>ntpd</code> (<code>service_pattern.pp</code>):</p>

<pre><code class="Shell">service { 'ntp':
  ensure    =&gt; running,
  enable    =&gt; true,
  hasstatus =&gt; false,
  pattern   =&gt; 'ntpd',
}
</code></pre>

<p>As in:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~$ ps -ax | grep ntpd
 5795 ?        Ss     0:00 /usr/sbin/ntpd -p /var/run/ntpd.pid -g -u 112:116
 7448 pts/0    S+     0:00 grep --color=auto ntpd
</code></pre>

<h5 id="thehasrestartandrestartattributes">The hasrestart and restart attributes</h5>

<p>When a service is notified (for example, if a <code>file</code> resource uses the <code>notify</code> attribute to tell the service its config file has changed, a common pattern which we looked at in Chapter 2, _Creating your first manifests)_, Puppet&#8217;s default behaviour is to stop the service, then start it again. </p>

<p>This usually works, but many services implement a <code>restart</code> command in their management scripts. </p>

<p>If this is available, it&#8217;s usually a good idea to use it: it may be faster or safer than stopping and starting the service. </p>

<p>Some services take a while to shut down properly when stopped, for example, and Puppet may not wait long enough before trying to restart them, so that you end up with the service not running at all.</p>

<p>If you specify <code>hasrestart =&gt; true</code> for a service, then Puppet will try to send a <code>restart</code> command to it, using whatever service management command is appropriate for the current platform (<code>systemctl</code>, for example, on Ubuntu). </p>

<p>The following example shows the use of <code>hasrestart</code> (<code>service_hasrestart.pp</code>):</p>

<pre><code class="Shell">service { 'ntp':
  ensure     =&gt; running,
  enable     =&gt; true,
  hasrestart =&gt; true,
}
</code></pre>

<p>To further complicate things, the default system service <code>restart</code> command may not work, or you may need to take certain special actions when the service is restarted (disabling monitoring notifications, for example). </p>

<p>You can specify any <code>restart</code> command you like for the service using the <code>restart</code> attribute (<code>service_custom_restart.pp</code>):</p>

<pre><code class="Shell">service { 'ntp':
  ensure  =&gt; running,
  enable  =&gt; true,
  restart =&gt; '/bin/echo Restarting &gt;&gt;/tmp/debug.log &amp;&amp; systemctl restart ntp',
}
</code></pre>

<p>In this example, the <code>restart</code> command writes a message to a log file before restarting the service in the usual way, but it could, of course, do anything you need it to. </p>

<p>Note that the <code>restart</code> command is only used when Puppet restarts the service (generally because it was notified by a change to some config file). </p>

<p>It&#8217;s not used when starting the service from a stopped state. </p>

<p>If Puppet finds the service has stopped and needs to start it, it will use the normal system service start command.</p>

<p>In the extremely rare event that the service cannot be stopped or started using the default service management command, Puppet also provides the <code>stop</code> and <code>start</code> attributes so that you can specify custom commands to stop and start the service, just the same way as with the <code>restart</code> attribute. </p>

<p>If you need to use either of these, though, it&#8217;s probably safe to say that you&#8217;re having a bad day.</p>

<h4 id="users">Users</h4>

<p>A user on Unix-like systems does not necessarily correspond to a human person who logs in and types commands, although it sometimes does. A user is simply a named entity that can own files and run commands with certain permissions and that may or may not have permission to read or modify other users&#8217; files. It&#8217;s very common, for sound security reasons, to run each service on a system with its own user account. This simply means that the service runs with the identity and permissions of that user.</p>

<p>For example, a web server will often run as the <code>www-data</code> user, which exists solely to own files the web server needs to read and write. This limits the danger of a security breach via the web server, because the attacker would only have the <code>www-data</code> user&#8217;s permissions, which are very limited, rather than the <code>root</code> user&#8217;s, which can modify any aspect of the system. It is generally a bad idea to run services exposed to the public Internet as the <code>root</code> user. The service user should have only the minimum permissions it needs to operate the service.</p>

<p>Given this, an important part of system configuration involves creating and managing users, and Puppet&#8217;s <code>user</code> resource provides a model for doing just that. Just as we saw with packages and services, the details of implementation and the commands used to manage users vary widely from one operating system to another, but Puppet provides an abstraction which hides those details behind a common set of attributes for users.</p>

<h5 id="creatingusers">Creating Users</h5>

<p>The following example shows a typical <code>user</code> and <code>group</code> declaration in Puppet (<code>user.pp</code>):</p>

<pre><code class="Shell">group { 'devs':
  ensure =&gt; present,
  gid    =&gt; 3000,
}

user { ‘juniper nine’:
  ensure =&gt; present,
  uid    =&gt; '3001',
  home   =&gt; '/home/junipernine’,
  shell  =&gt; '/bin/bash',
  groups =&gt; ['devs'],
}
</code></pre>

<p>Which outputs:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/tmp$ sudo puppet apply /examples/user.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.01 seconds
Notice: /Stage[main]/Main/Group[devs]/ensure: created
Notice: /Stage[main]/Main/User[junipernine]/ensure: created
Notice: Applied catalog in 0.05 seconds
</code></pre>

<p>And did this:</p>

<pre><code class="Shell">cat /etc/passwd
junipernine:x:3001:3001::/home/junipernine:/bin/bash

cat /etc/group
devs:x:3000:junipernine
junipernine:x:3001:

</code></pre>

<h5 id="theuserresource">The User resource</h5>

<p>The title of the resource is the username (login name) of the user; in this example, <code>juniper nine</code>. The <code>ensure =&gt; present</code> attribute says that the user should exist on the system.</p>

<p>The <code>uid</code> attribute needs a little more explanation. </p>

<p>On Unix-like systems, each user has an individual numerical id, known as the <strong>uid</strong>. The text name associated with the user is merely a convenience for those (mere humans, for example) who prefer strings to numbers. </p>

<p>Access permissions are in fact based on the uid and not the username.</p>

<p>Why set the <code>uid</code> attribute? </p>

<p>Often, when creating users manually, we don&#8217;t specify a uid, so the system will assign one automatically. The problem with this is that if you create the same user (<code>juniper nine</code>, for example) on three different nodes, you may end up with three different uids. </p>

<p>This would be fine as long as you have never shared files between nodes, or copied data from one place to another. But in fact, this happens all the time, so it&#8217;s important to make sure that a given user&#8217;s uid is the same across all the nodes in your infrastructure. </p>

<p>That&#8217;s why we specify the <code>uid</code> attribute in the Puppet manifest.</p>

<p>The <code>home</code> attribute sets the user&#8217;s home directory (this will be the current working directory when the user logs in, if she does log in, and also the default working directory for cron jobs that run as the user).</p>

<p>The <code>shell</code> attribute specifies the command-line shell to run when the user logs in interactively. For humans, this will generally be a user shell, such as <code>/bin/bash</code> or <code>/bin/sh</code>. </p>

<p>For service users, such as <code>www-data</code>, the shell should be set to <code>/usr/sbin/nologin</code> (on Ubuntu systems), which does not allow interactive access, and prints a message saying <code>This account is currently not available</code>. All users who do not need to log in interactively should have the <code>nologin</code> shell.</p>

<p>If the user needs to be a member of certain groups, you can pass the <code>groups</code> attribute an array of the group names (just <code>devs</code> in this example).</p>

<p>Although Puppet supports a <code>password</code> attribute for <code>user</code> resources, I don&#8217;t advise you to use it. Service users don&#8217;t need passwords, and interactive users should be logging in with SSH keys. In fact, you should configure SSH to disable password logins altogether (set <code>PasswordAuthentication no</code> in <code>sshd_config</code>).</p>

<h5 id="thegroupresource">The group resource</h5>

<p>The title of the resource is the name of the group (<code>devs</code>). </p>

<p>You need not specify a <code>gid</code> attribute but, for the same reasons as the <code>uid</code> attribute, it&#8217;s a good idea to do so.</p>

<h5 id="managingsshkeys">Managing ssh keys</h5>

<p>I like to have as few interactive logins as possible on production nodes, because it reduces the attack surface. Fortunately, with configuration management, it should rarely be necessary to actually log in to a node. </p>

<p>The most common reasons for needing an interactive login are for system maintenance and troubleshooting, and for deployment. </p>

<p>In both cases there should be a single account named for this specific purpose (for example, <code>admin</code> or <code>deploy</code>), and it should be configured with the SSH keys of any users or systems that need to log in to it.</p>

<p>Puppet provides the <code>ssh_authorized_key</code> resource to control the SSH keys associated with a user account. </p>

<p>The following example shows how to use <code>ssh_authorized_key</code> to add an SSH key (mine, in this instance) to the <code>ubuntu</code> user on our Vagrant VM (<code>ssh_authorized_key.pp</code>):</p>

<pre><code class="Shell">ssh_authorized_key { ‘anthony@junipernine.com':
  user =&gt; 'ubuntu',
  type =&gt; 'ssh-rsa',
  key  =&gt; 'AAAAB3NzaC1yc2EAAAABIwAAAIEA3ATqENg+GWACa2BzeqTdGnJhNoBer8x6pfWkzNzeM8Zx7/2Tf2pl7kHdbsiTXEUawqzXZQtZzt/j3Oya+PZjcRpWNRzprSmd2UxEEPTqDw9LqY5S2B8og/NyzWaIYPsKoatcgC7VgYHplcTbzEhGu8BsoEVBGYu3IRy5RkAcZik=',
}
</code></pre>

<ul>
<li>The title of the resource is the SSH key comment, which reminds us who the key belongs to.</li>
<li>The <code>user</code> attribute specifies the user account which this key should be authorized for.</li>
<li>The <code>type</code> attribute identifies the SSH key type, usually <code>ssh-rsa</code> or <code>ssh-dss</code>.</li>
<li>The <code>key</code> attribute sets the key itself.</li>
</ul>

<p>When this manifest is applied, it adds the following to the <code>ubuntu</code> user&#8217;s <code>authorized_keys</code> file:</p>

<pre><code class="Shell">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA3ATqENg+GWACa2BzeqTdGnJhNoBer8x6pfWkzNzeM8Zx7/2Tf2pl7kHdbsiTXEUawqzXZQtZzt/j3Oya+PZjcRpWNRzprSmd2UxEEPTqDw9LqY5S2B8og/NyzWaIYPsKoatcgC7VgYHplcTbzEhGu8BsoEVBGYu3IRy5RkAcZik= anthony@junipernine.com
</code></pre>

<p>A user account can have multiple SSH keys associated with it, and anyone holding one of the corresponding private keys and its passphrase will be able to log in as that user.</p>

<h5 id="removingusers">Removing Users</h5>

<p>If you need to have Puppet remove user accounts (for example, as part of an employee leaving process), it&#8217;s not enough to simply remove the <code>user</code> resource from the Puppet manifest. </p>

<p>Puppet will ignore any users on the system that it doesn&#8217;t know about, and it certainly will not remove anything it finds on the system that isn&#8217;t mentioned in the Puppet manifest; that would be extremely undesirable (almost everything would be removed). </p>

<p>So we need to retain the <code>user</code> declaration for a while, but set the <code>ensure`` attribute to </code>absent<code> (</code>user_remove.pp```):</p>

<pre><code class="Shell">user { 'godot':
  ensure =&gt; absent,
}

</code></pre>

<p>Once Puppet has run everywhere, you can remove the <code>user</code> resource if you like, but it does no harm to simply leave it in place, and in fact, it&#8217;s a good idea to do this, unless you can verify manually that the user has been deleted from every affected system.</p>

<p>If you need to prevent a user logging in, but want to retain the account and any files owned by the user, for archival or compliance purposes, you can set their <code>shell</code> to <code>/usr/sbin/nologin</code>. </p>

<p>You can also remove any <code>ssh_authorized_key</code> resources associated with their account, and set the <code>purge_ssh_keys</code> attribute to <code>true</code> on the <code>user</code> resource. </p>

<p>This will remove any authorised keys for the user that are not managed by Puppet.</p>

<h4 id="cron">Cron</h4>

<p>Cron is the mechanism on Unix-like systems which runs scheduled jobs, sometimes known as batch jobs, at specified times or intervals. For example, system housekeeping tasks, such as log rotation or checking for security updates, are run from cron. </p>

<p>The details of what to run and when to run it are kept in a specially formatted file called <code>crontab</code> (short for <strong>cron table</strong>).</p>

<p>Puppet provides the <code>cron</code> resource for managing scheduled jobs, and we saw an example of this in the <code>run-puppet</code> manifest we developed in Chapter 3, <em>Managing your Puppet code with Git</em> (<code>run-puppet.pp</code>):</p>

<pre><code class="Shell">cron { 'run-puppet':
  command =&gt; '/usr/local/bin/run-puppet',
  hour    =&gt; '*',
  minute  =&gt; '*/15',
}
</code></pre>

<p>The title <code>run-puppet</code> identifies the cron job (Puppet writes a comment to the <code>crontab</code> file containing this name to distinguish it from other manually-configured cron jobs). </p>

<p>The <code>command</code> attribute specifies the command for cron to run, and the <code>hour</code> and <code>minute</code> specify the time (<code>*/15</code> is a cron syntax, meaning &#8220;every 15 minutes&#8221;).</p>

<p>For more information about cron and the possible ways to specify the times of scheduled jobs, run the command <code>man 5 crontab</code>.</p>

<h5 id="attributesofthecronresource">Attributes of the cron resource</h5>

<p>The ``cron<code> resource has a few other useful attributes which are shown in the following example (</code>cron.pp```):</p>

<pre><code class="Shell">cron { 'cron example':
  command     =&gt; '/bin/date +%F',
  user        =&gt; 'ubuntu',
  environment =&gt; ['MAILTO=admin@example.com', 'PATH=/bin'],
  hour        =&gt; '0',
  minute      =&gt; '0',
  weekday     =&gt; ['Saturday', 'Sunday'],
}
</code></pre>

<p>The <code>user</code> attribute specifies who should run the cron job (if none is specified, the job runs as <code>root</code>). If the <code>environment</code> attribute is given, it sets any environment variables the cron job might need. A common use for this is to email any output from the cron job to a specified email address, using the <code>MAILTO</code> variable.</p>

<p>As before, the <code>hour</code> and <code>minute</code> attributes set the time for the job to run, while you can use the <code>weekday</code> attribute to specify a particular day, or days, of the week. (The <code>monthday</code> attribute works the same way, and can take any range or array of values between 1&#8211;31 to specify the day of the month.)</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~/puppet/examples$ sudo puppet apply /examples/cron.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.04 seconds
Notice: /Stage[main]/Main/Cron[cron example]/ensure: created
Notice: Applied catalog in 0.04 seconds

vagrant@ubuntu-xenial:~/puppet/examples$ sudo crontab -l
# HEADER: This file was autogenerated at 2018-10-17 10:39:06 +0000 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: run-puppet
*/15 * * * * /usr/local/bin/run-puppet

vagrant@ubuntu-xenial:~/puppet/examples$ su - ubuntu
Password:

ubuntu@ubuntu-xenial:~$ crontab -l
# HEADER: This file was autogenerated at 2018-10-18 12:12:17 +0000 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: cron example
MAILTO=admin@example.com
PATH=/bin
0 0 * * 6,0 /bin/date +%F
</code></pre>

<p>One important point about cron scheduling is that the default value for any schedule attribute is <code>*</code>, which means <em>all allowed values</em>. </p>

<p>For example, if you do not specify an <code>hour</code> attribute, the cron job will be scheduled with an <code>hour</code> of <code>*</code>, meaning that it will run every hour. </p>

<p>This is generally not what you want. If you do want it to run every hour, specify <code>hour =&gt; ‘*’</code> in your manifest, but otherwise, specify the particular hour it should run at.</p>

<p>The same goes for <code>minute</code>. Accidentally leaving out the <code>minute</code> attribute and having a job run sixty times an hour can have amusing consequences, to say the least.</p>

<h5 id="randomisingcronjobs">Randomising cronjobs</h5>

<p>If you run a cron job on many nodes, it&#8217;s a good idea to make sure the job doesn&#8217;t run everywhere at the same time. Puppet provides a built-in function <code>fqdn_rand()</code> to help with this; it provides a random number up to a specified maximum value, which will be different on each node, because the random number generator is seeded with the node&#8217;s hostname.</p>

<p>If you have several such jobs to run, you can also supply a further seed value to the <code>fqdn_rand()</code> function, which can be any string and which will ensure that the value is different for each job (<code>fqdn_rand.pp</code>):</p>

<pre><code class="Shell">cron { 'run daily backup':
  command =&gt; '/usr/local/bin/backup',
  minute  =&gt; '0',
  hour    =&gt; fqdn_rand(24, 'run daily backup'),
}

cron { 'run daily backup sync':
  command =&gt; '/usr/local/bin/backup_sync',
  minute  =&gt; '0',
  hour    =&gt; fqdn_rand(24, 'run daily backup sync'),
}

</code></pre>

<p>Output:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:~/puppet/examples$ sudo puppet apply /examples/fqdn_rand.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.04 seconds
Notice: /Stage[main]/Main/Cron[run daily backup]/ensure: created
Notice: /Stage[main]/Main/Cron[run daily backup sync]/ensure: created
Notice: Applied catalog in 0.03 seconds

vagrant@ubuntu-xenial:~/puppet/examples$ sudo crontab -l
# HEADER: This file was autogenerated at 2018-10-18 12:23:26 +0000 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: run-puppet

*/15 * * * * /usr/local/bin/run-puppet
# Puppet Name: run daily backup
0 22 * * * /usr/local/bin/backup
# Puppet Name: run daily backup sync
0 11 * * * /usr/local/bin/backup_sync
</code></pre>

<p>Because we gave a different string as the second argument to <code>fqdn_rand</code> for each cron job, it will return a different random value for each <code>hour</code> attribute.</p>

<p>The range of values returned by <code>fqdn_rand()</code> includes 0, but does not include the maximum value you specify. So, in the previous example, the values for <code>hour</code> will be between 0 and 23, inclusive.</p>

<h5 id="removingcronjobs">Removing cron jobs</h5>

<p>Just as with <code>user</code> resources, or any type of resource, removing the resource declaration from your Puppet manifest does not remove the corresponding configuration from the node. </p>

<p>In order to do that you need to specify <code>ensure =&gt; absent</code> on the resource.</p>

<h4 id="exec">Exec</h4>

<p>While the other resource types we&#8217;ve seen so far (<code>file</code>, <code>package</code>, <code>service</code>, <code>user</code>, <code>ssh_authorized_key</code>, and <code>cron</code>) have modelled some concrete piece of state on the node, such as a file, the <code>exec</code> resource is a little different. </p>

<p>An <code>exec</code> allows you to run any arbitrary command on the node. This might create or modify state, or it might not; anything you can run from the command line, you can run via an <code>exec</code> resource.</p>

<h5 id="automatingmanualinteraction">Automating manual interaction</h5>

<p>The most common use for an <code>exec</code> resource is to simulate manual interaction on the command line. </p>

<p>Some older software is not packaged for modern operating systems, and needs to be compiled and installed from source, which requires you to run certain commands. The authors of some software have also not realised, or don&#8217;t care, that users may be trying to install their product automatically and have install scripts which prompt for user input. </p>

<p>This can require the use of <code>exec</code> resources to work around the problem.</p>

<h5 id="attributesoftheexecresource">Attributes of the exec resource</h5>

<p>The following example shows an exec resource for building and installing an imaginary piece of software (<code>exec.pp</code>):</p>

<pre><code class="Shell">exec { 'install-cat-picture-generator':
  cwd     =&gt; '/tmp/cat-picture-generator',
  command =&gt; '/tmp/cat-picture/generator/configure &amp;&amp; /usr/bin/make install',
  creates =&gt; '/usr/local/bin/cat-picture-generator',
}
</code></pre>

<p>The title of the resource can be anything you like, though, as usual with Puppet resources it must be unique. I tend to name <code>exec</code> resources after the problem they&#8217;re trying to solve, as in this example.</p>

<p>The <code>cwd</code> attribute sets the working directory where the command will be run (<strong>current working directory</strong>). When installing software, this is generally the software source directory. The <code>command</code> attribute gives the command to run. </p>

<p>This must be the full path to the command, but you can chain several commands together using the shell <code>&amp;&amp;</code> operator. This executes the next command only if the previous one succeeded, so in the example, if the <code>configure</code> command completes successfully, Puppet will go on to run <code>make install</code>, otherwise, it will stop with an error.</p>

<p>If you apply this example, Puppet will give you an error like the following:</p>

<pre><code class="Shell">Error: /Stage[main]/Main/Exec[install-cat-picture-generator]/returns: change from notrun to 0 failed: Could not find command '/tmp/cat-picture/generator/configure'
</code></pre>

<p>This is expected because the specified command does not, in fact, exist. In your own manifests, you may see this error if you give the wrong path to a command, or if the package that provides the command hasn&#8217;t been installed yet.</p>

<p>The <code>creates</code> attribute specifies a file which should exist after the command has been run. If this file is present, Puppet will not run the command again. This is very useful because without a <code>creates</code> attribute, an <code>exec</code> resource will run every time Puppet runs, which is generally not what you want. The <code>creates</code> attribute tells Puppet, in effect, &quot;Run the <code>exec</code> only if this file doesn&#8217;t exist.&quot;</p>

<p>Let&#8217;s see how this works, imagining that this <code>exec</code> is being run for the first time. We assume that the <code>/tmp/cat-picture/</code> directory exists and contains the source of the <code>cat-picture-generator</code> application.</p>

<ul>
<li>Puppet checks the <code>creates</code> attribute and sees that the <code>/usr/local/bin/cat-picture-generator</code> file is not present; therefore, the <code>exec</code> resource must be run.</li>
<li>Puppet runs the <code>/tmp/cat-picture-generator/configure &amp;&amp; /usr/bin/make install</code> command. As a side effect of these commands, the <code>/usr/local/bin/cat-picture-generator</code> file is created.</li>
<li>Next time Puppet runs, it again checks the <code>creates</code> attribute. This time <code>/usr/local/bin/cat-picture-generator</code> exists, so Puppet does nothing.</li>
</ul>

<p>This <code>exec</code> resource will never be applied again so long as the file specified in the <code>creates</code> attribute exists. You can test this by deleting the file and applying Puppet again. The <code>exec</code> resource will be triggered and the file recreated.</p>

<p>Make sure that your <code>exec</code> resources always include a <code>creates</code> attribute (or a similar control attribute, such as <code>onlyif</code> or <code>unless</code>, which we&#8217;ll look at later in this chapter). Without this, the <code>exec</code> command will be run every time Puppet runs, which is almost certainly not what you want.</p>

<p>Note that building and installing software from source is not a recommended practice for production systems. </p>

<p>It&#8217;s better to build the software on a dedicated build server (perhaps using Puppet code similar to this example), create a system package for it, and then use Puppet to install that package on production nodes.</p>

<h5 id="theuserattribute">The user attribute</h5>

<p>If you don&#8217;t specify a <code>user</code> attribute for an <code>exec</code> resource, Puppet will run the command as the <code>root</code> user. </p>

<p>This is often appropriate for installing system software or making changes to the system configuration, but if you need the command to run as a particular user, specify the <code>user</code> attribute, as in the following example (<code>exec_user.pp</code>):</p>

<pre><code class="Shell">exec { 'say-hello':
  command =&gt; '/bin/echo Hello, this is `whoami` &gt;/tmp/hello-ubuntu.txt',
  user    =&gt; 'ubuntu',
  creates =&gt; '/tmp/hello-ubuntu.txt',
}
</code></pre>

<p>This will run the specified command as the <code>ubuntu</code> user. </p>

<p>The <code>whoami</code> command returns the name of the user running it, so when you apply this manifest, the file <code>/tmp/hello-ubuntu.txt</code> will be created with the following contents:</p>

<pre><code class="Shell">Hello, this is ubuntu
</code></pre>

<p>As with the earlier example, the <code>creates</code> attribute prevents Puppet from running this command more than once.</p>

<p><strong>NB..</strong> This test is far more demonstrable by removing the text file and running it again.</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/tmp$ sudo puppet apply /examples/exec_user.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.05 seconds
Notice: /Stage[main]/Main/Exec[say-hello]/returns: executed successfully
Notice: Applied catalog in 0.02 seconds

vagrant@ubuntu-xenial:/tmp$ ls
hello-ubuntu.txt  ssh-EvbeMoesso  vagrant-shell  vboxguest-Module.symvers

vagrant@ubuntu-xenial:/tmp$ cat hello-ubuntu.txt
Hello, this is ubuntu

vagrant@ubuntu-xenial:/tmp$ sudo puppet apply /examples/exec_user.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.05 seconds
Notice: Applied catalog in 0.01 seconds

vagrant@ubuntu-xenial:/tmp$ sudo rm hello-ubuntu.txt

vagrant@ubuntu-xenial:/tmp$ sudo puppet apply /examples/exec_user.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.05 seconds
Notice: /Stage[main]/Main/Exec[say-hello]/returns: executed successfully
Notice: Applied catalog in 0.02 seconds
</code></pre>

<h5 id="theonlyifandunlessattributes">The onlyif and unless attributes</h5>

<p>Suppose you only want an <code>exec</code> resource to be applied under certain conditions. For example, a command which processes incoming data files only needs to run if there are data files waiting to be processed. </p>

<p>In this case, it&#8217;s no good adding a <code>creates</code> attribute; we want the existence of a certain file to trigger the <code>exec</code>, not prevent it.</p>

<p>The <code>onlyif</code> attribute is a good way to solve this problem. It specifies a command for Puppet to run, and the exit status from this command determines whether or not the <code>exec</code> will be applied. </p>

<p>On Unix-like systems, commands generally return an exit status of zero to indicate success and a non-zero value for failure. </p>

<p>The following example shows how to use <code>onlyif</code> in this way (<code>exec_onlyif.pp</code>):</p>

<pre><code class="Shell">exec { 'process-incoming-cat-pictures':
  command =&gt; '/usr/local/bin/cat-picture-generator --import /tmp/incoming/*',
  onlyif  =&gt; '/bin/ls /tmp/incoming/*',
}
</code></pre>

<p>The exact command isn&#8217;t important here, but let&#8217;s assume it&#8217;s something that we would only want to run if there are any files in the <code>/tmp/incoming/</code> directory.</p>

<p>The <code>onlyif</code> attribute specifies the check command which Puppet should run first, to determine whether or not the <code>exec</code> resource needs to be applied. If there is nothing in the <code>/tmp/incoming/</code> directory, then <code>ls /tmp/incoming/*</code> will return a non-zero exit status. Puppet interprets this as failure, so does not apply the <code>exec</code> resource.</p>

<p>On the other hand, if there are files in the <code>/tmp/incoming/</code> directory, the <code>ls</code> command will return success. This tells Puppet the <code>exec</code> resource must be applied, so it proceeds to run the <code>/usr/local/bin/cat-picture-generator</code> command (and we can assume this command deletes the incoming files after processing).
You can think of the <code>onlyif</code> attribute as telling Puppet, &quot;Run the <code>exec</code> resource <em>only if </em> this command succeeds.&quot;</p>

<p>The <code>unless</code> attribute is exactly the same as <code>onlyif</code> but with the opposite sense. If you specify a command to the <code>unless</code> attribute, the <code>exec</code> will always be run unless the command returns a zero exit status. You can think of <code>unless</code> as telling Puppet, &quot;Run the <code>exec</code> resource <em>unless</em> this command succeeds.”

When you apply your manifest, if you see an <code>exec</code> resource running every time which shouldn&#8217;t be, check whether it specifies a <code>creates</code>, <code>unless</code>, or <code>onlyif</code> attribute. </p>

<p>If it specifies the <code>creates</code> attribute, it may be looking for the wrong file; if the <code>unless</code> or <code>onlyif</code> command is specified, it may not be returning what you expect. </p>

<p>You can see what command is being run and what output it generates by running <code>sudo puppet apply</code> with the <code>-d</code> (debug) flag:</p>

<pre><code class="Shell">sudo puppet apply -d exec_onlyif.pp
Debug: Exec[process-incoming-cat-pictures](provider=posix): Executing check '/bin/ls /tmp/incoming/*'
Debug: Executing: '/bin/ls /tmp/incoming/*'
Debug: /Stage[main]/Main/Exec[process-incoming-cat-pictures]/onlyif: /tmp/incoming/foo
</code></pre>

<p><strong>NB.</strong> In reality it is far more verbose than this.</p>

<h5 id="therefreshonlyattribute">The refreshonly attribute</h5>

<p>It&#8217;s quite common to use <code>exec</code> resources for one-off commands, such as rebuilding a database, or setting a system-tunable parameter. </p>

<p>These generally only need to be triggered once, when a package is installed, or occasionally, when a config file is updated. If an <code>exec</code> resource needs to run only when some other Puppet resource is changed, we can use the <code>refreshonly</code> attribute to do this.
If <code>refreshonly</code> is <code>true</code>, the <code>exec</code> will never be applied unless another resource triggers it with <code>notify</code>. </p>

<p>In the following example, Puppet manages the <code>/etc/aliases</code> file (which maps local usernames to email addresses), and a change to this file triggers the execution of the command <code>newaliases</code>, which rebuilds the system alias database (<code>exec_refreshonly.pp</code>):</p>

<pre><code class="Shell">file { '/etc/aliases':
  content =&gt; 'root: anthony@junipernine.com',
  notify  =&gt; Exec['newaliases'],
}

exec { 'newaliases':
  command     =&gt; '/usr/bin/newaliases',
  refreshonly =&gt; true,
}
</code></pre>

<p>When this manifest is applied for the first time, the <code>/etc/aliases</code> resource causes a change to the file&#8217;s contents, so Puppet sends a <code>notify</code> message to the <code>exec</code> resource. </p>

<p>This causes the <code>newaliases</code> command to be run. </p>

<p>If you apply the manifest again, you will see that the <code>aliases</code> file is not changed, so the <code>exec</code> is not run.</p>

<p>Results:</p>

<pre><code class="Shell">Info: Computing checksum on file /etc/aliases
Info: /Stage[main]/Main/File[/etc/aliases]: Filebucketed /etc/aliases to puppet with sum 52417f6dfdf4444dd00691e149e0f7ea
Notice: /Stage[main]/Main/File[/etc/aliases]/content: content changed '{md5}52417f6dfdf4444dd00691e149e0f7ea' to '{md5}b8c04af5e2ab8070de8de8293bd03540'
Info: /Stage[main]/Main/File[/etc/aliases]: Scheduling refresh of Exec[newaliases]
Debug: /Stage[main]/Main/File[/etc/aliases]: The container Class[Main] will propagate my refresh event
Debug: Exec[newaliases](provider=posix): Executing '/usr/bin/newaliases'
Debug: Executing: '/usr/bin/newaliases'
Notice: /Stage[main]/Main/Exec[newaliases]: Triggered 'refresh' from 1 event
Debug: /Stage[main]/Main/Exec[newaliases]: The container Class[Main] will propagate my refresh event
Debug: Class[Main]: The container Stage[main] will propagate my refresh event
Debug: Finishing transaction 27768540
</code></pre>

<p>Run again:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/tmp$ sudo puppet apply /examples/exec_refreshonly.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.50 seconds
Notice: Applied catalog in 0.02 seconds
</code></pre>

<p>Add a row:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/tmp$ sudo cat /etc/aliases
root: admin@example.com
aj9: anthony@junipernine.com
</code></pre>

<p>Run again:</p>

<pre><code class="Shell">vagrant@ubuntu-xenial:/tmp$ sudo puppet apply /examples/exec_refreshonly.pp
Notice: Compiled catalog for ubuntu-xenial.lan in environment production in 0.50 seconds
Notice: /Stage[main]/Main/File[/etc/aliases]/content: content changed '{md5}4ed1e8970ebcf6a644c80947077d771f' to '{md5}b8c04af5e2ab8070de8de8293bd03540'
Notice: /Stage[main]/Main/Exec[newaliases]: Triggered 'refresh' from 1 event
Notice: Applied catalog in 0.05 seconds
</code></pre>

<p>Triggered the event again.</p>

<p>While the <code>refreshonly</code> attribute is occasionally extremely useful, over-use of it can make your Puppet manifests hard to understand and debug, and it can also be rather fragile. Felix Frank makes this point in a blog post, <em>Friends Don&#8217;t Let Friends Use Refreshonly</em>:
<code>Email
”With the </code>exec<code> resource type considered the last ditch, its </code>refreshonly<code> parameter should be seen as especially outrageous. To make an </code>exec<code> resource fit into Puppet's model better, you should use [the </code>creates<code>, </code>onlyif<code>, or </code>unless<code>] parameters instead.&quot; 
</code></p>

<p>Refer to:</p>

<p>http://ffrank.github.io/misc/2015/05/26/friends-don&#8217;t-let-friends-use-refreshonly/</p>

<p>Note that you don&#8217;t need to use the <code>refreshonly</code> attribute in order to make the <code>exec</code> resource notifiable by other resources. Any resource can notify an <code>exec</code> resource in order to make it run; however, if you don&#8217;t want it to run <em>unless</em>  it&#8217;s notified, use <code>refreshonly</code>.</p>

<p>By the way, if you actually want to manage email aliases on a node, use Puppet&#8217;s built-in <code>mailalias</code> resource. The previous example is just to demonstrate the use of <code>refreshonly</code>.</p>

<h5 id="thelogoutputattribute">The logoutput attribute</h5>

<p>When Puppet runs shell commands via an <code>exec</code> resource, the output is normally hidden from us. However, if the command doesn&#8217;t seem to be working properly, it can be very useful to see what output it produced, as this usually tells us why it didn&#8217;t work.</p>

<p>The <code>logoutput</code> attribute determines whether Puppet will log the output of the <code>exec</code> command along with the usual informative Puppet output. It can take three values: <code>true</code>, <code>false</code>, or <code>on_failure</code>.</p>

<p>If <code>logoutput</code> is set to <code>on_failure</code> (which is the default), Puppet will only log command output when the command fails (that is, returns a non-zero exit status). </p>

<p>If you never want to see command output, set it to <code>false</code>.</p>

<p>Sometimes, however, the command returns a successful exit status but does not appear to do anything. Setting <code>logoutput</code> to <code>true</code> will force Puppet to log the command output regardless of exit status, which should help you figure out what&#8217;s going on.</p>

<h5 id="thetimeoutattribute">The timeout attribute</h5>

<p>Sometimes, commands can take a long time to run, or never terminate at all. </p>

<p>By default, Puppet allows an <code>exec</code> command to run for 300 seconds, at which point Puppet will terminate it if it has not finished. </p>

<p>If you need to allow a little longer for the command to complete, you can use the <code>timeout</code> attribute to set this. The value is the maximum execution time for the command in seconds.</p>

<p>Setting a <code>timeout</code> value of <code>0</code> disables the automatic timeout altogether and allows the command to run forever. </p>

<p>This should be the last resort, as a command which blocks or hangs could stop Puppet&#8217;s automatic runs altogether if no timeout is set. </p>

<p>To find a suitable value for <code>timeout</code>, try running the command a few times and choose a value which is perhaps twice as long as a typical run. </p>

<p>This should avoid failures caused by slow network conditions, for example, but not block Puppet from running altogether.</p>

<h5 id="hownottomisuseexecresources">How not to misuse exec resources</h5>

<p>The <code>exec</code> resource can do anything to the system that you could do from the command line. As you can imagine, such a powerful tool can be misused. </p>

<p>In theory, Puppet is a declarative language: the manifest specifies the way things should be, and it is up to Puppet to take the necessary actions to make them so. </p>

<p>Manifests are therefore what computer scientists call <strong>idempotent</strong>: the system is always in the same state after the catalog has been applied, and however many times you apply it, it will always be in that state.</p>

<p>The <code>exec</code> resource rather spoils this theoretical picture, by allowing Puppet manifests to have side-effects. Since your <code>exec</code> command can do anything, it could, for example, create a new 1 GB file on disk with a random name, and since this will happen every time Puppet runs, you could rapidly run out of disk space. </p>

<p>It&#8217;s best to avoid commands with side-effects like this. In general, there&#8217;s no way to know from within Puppet exactly what changes to a system were caused by an <code>exec</code> resource.</p>

<p>Commands run via <code>exec</code> are also sometimes used to bypass Puppet&#8217;s existing resources. For example, if the <code>user</code> resource doesn&#8217;t do quite what you want for some reason, you could create a user by running the <code>adduser</code> command directly from an <code>exec</code>. </p>

<p>This is also a bad idea, since by doing this you lose the declarative and cross-platform nature of Puppet&#8217;s built-in resources. </p>

<p><code>exec</code> resources potentially change the state of the node in a way that&#8217;s invisible to Puppet&#8217;s catalog.</p>

</body>
</html>
